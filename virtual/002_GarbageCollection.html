<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>垃圾回收器与内存分配策略 | Koala &#39;s blog</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    <meta name="description" content="欢迎来到我的博客">
    <link rel="preload" href="/assets/css/0.styles.0dca6718.css" as="style"><link rel="preload" href="/assets/js/app.193c9b61.js" as="script"><link rel="preload" href="/assets/js/2.be286493.js" as="script"><link rel="preload" href="/assets/js/66.3db4dcf7.js" as="script"><link rel="prefetch" href="/assets/js/10.d195f939.js"><link rel="prefetch" href="/assets/js/11.dd42e2a6.js"><link rel="prefetch" href="/assets/js/12.ee2c872c.js"><link rel="prefetch" href="/assets/js/13.788181fe.js"><link rel="prefetch" href="/assets/js/14.923b40d7.js"><link rel="prefetch" href="/assets/js/15.be1e8f2a.js"><link rel="prefetch" href="/assets/js/16.a5861f2e.js"><link rel="prefetch" href="/assets/js/17.0ca1cca8.js"><link rel="prefetch" href="/assets/js/18.3552af88.js"><link rel="prefetch" href="/assets/js/19.d0b598dd.js"><link rel="prefetch" href="/assets/js/20.312fba46.js"><link rel="prefetch" href="/assets/js/21.de99e5de.js"><link rel="prefetch" href="/assets/js/22.4cb1ef09.js"><link rel="prefetch" href="/assets/js/23.2e9ea85a.js"><link rel="prefetch" href="/assets/js/24.1cd100b8.js"><link rel="prefetch" href="/assets/js/25.c17ed571.js"><link rel="prefetch" href="/assets/js/26.cee42a14.js"><link rel="prefetch" href="/assets/js/27.34b9e8bb.js"><link rel="prefetch" href="/assets/js/28.a0fd1666.js"><link rel="prefetch" href="/assets/js/29.cc16a8ba.js"><link rel="prefetch" href="/assets/js/3.e2b53d75.js"><link rel="prefetch" href="/assets/js/30.4b4a9808.js"><link rel="prefetch" href="/assets/js/31.55d17ac2.js"><link rel="prefetch" href="/assets/js/32.e6285297.js"><link rel="prefetch" href="/assets/js/33.2cf9fcd0.js"><link rel="prefetch" href="/assets/js/34.549b5096.js"><link rel="prefetch" href="/assets/js/35.fd8c8f14.js"><link rel="prefetch" href="/assets/js/36.db162c08.js"><link rel="prefetch" href="/assets/js/37.f105831d.js"><link rel="prefetch" href="/assets/js/38.d42b82e0.js"><link rel="prefetch" href="/assets/js/39.eb81783f.js"><link rel="prefetch" href="/assets/js/4.2837b6be.js"><link rel="prefetch" href="/assets/js/40.87c4c789.js"><link rel="prefetch" href="/assets/js/41.fc9b4279.js"><link rel="prefetch" href="/assets/js/42.c9148681.js"><link rel="prefetch" href="/assets/js/43.dbe26f4f.js"><link rel="prefetch" href="/assets/js/44.b1d85a5c.js"><link rel="prefetch" href="/assets/js/45.5a1e6a7a.js"><link rel="prefetch" href="/assets/js/46.bd963e4a.js"><link rel="prefetch" href="/assets/js/47.f6e86edc.js"><link rel="prefetch" href="/assets/js/48.bdbc5c65.js"><link rel="prefetch" href="/assets/js/49.65ae461d.js"><link rel="prefetch" href="/assets/js/5.3f71247d.js"><link rel="prefetch" href="/assets/js/50.66be60b2.js"><link rel="prefetch" href="/assets/js/51.42b1c641.js"><link rel="prefetch" href="/assets/js/52.bb9f5b94.js"><link rel="prefetch" href="/assets/js/53.3ed95f43.js"><link rel="prefetch" href="/assets/js/54.b989fa99.js"><link rel="prefetch" href="/assets/js/55.7799c2bd.js"><link rel="prefetch" href="/assets/js/56.95e3d2fa.js"><link rel="prefetch" href="/assets/js/57.47649eef.js"><link rel="prefetch" href="/assets/js/58.c3ce9734.js"><link rel="prefetch" href="/assets/js/59.1e092fb4.js"><link rel="prefetch" href="/assets/js/6.ba15ebf3.js"><link rel="prefetch" href="/assets/js/60.ae57b5f2.js"><link rel="prefetch" href="/assets/js/61.68ecf247.js"><link rel="prefetch" href="/assets/js/62.42a2fc04.js"><link rel="prefetch" href="/assets/js/63.819b8db9.js"><link rel="prefetch" href="/assets/js/64.8034f4d3.js"><link rel="prefetch" href="/assets/js/65.fa291912.js"><link rel="prefetch" href="/assets/js/67.a66d7e55.js"><link rel="prefetch" href="/assets/js/68.cbaf17d3.js"><link rel="prefetch" href="/assets/js/7.6f9d368d.js"><link rel="prefetch" href="/assets/js/8.516fa0e1.js"><link rel="prefetch" href="/assets/js/9.f1946ce5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0dca6718.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container custom-page-class"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">Koala 's blog</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          Home
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/design/">
          设计模式
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/algorithm/">
          算法相关
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-submenu-selected"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          java相关
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/virtual/" class="sidebar-link">介绍</a></li><li><a href="/virtual/001_jvmmemoryarea.html" class="sidebar-link">java内存区域</a></li><li><a href="/virtual/002_GarbageCollection.html" class="active sidebar-link">垃圾回收器与内存分配策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#一、-gc需要完成的3件事" class="sidebar-link">一、 GC需要完成的3件事</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#二、java内存运行时区域的各个部分" class="sidebar-link">二、java内存运行时区域的各个部分</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#三、引用计数算法" class="sidebar-link">三、引用计数算法</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#四、可达性算法" class="sidebar-link">四、可达性算法</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#五、引用" class="sidebar-link">五、引用</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#六、生存还是死亡" class="sidebar-link">六、生存还是死亡</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#七、回收方法区" class="sidebar-link">七、回收方法区</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#八、-垃圾收集算法" class="sidebar-link">八、 垃圾收集算法</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#九、分代收集算法" class="sidebar-link">九、	分代收集算法</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#十、垃圾收集器" class="sidebar-link">十、垃圾收集器</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#十一、内存分配与回收策略" class="sidebar-link">十一、内存分配与回收策略</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#十二、gc日志理解" class="sidebar-link">十二、GC日志理解</a></li><li class="sidebar-sub-header"><a href="/virtual/002_GarbageCollection.html#十三、虚拟机参数分析" class="sidebar-link">十三、虚拟机参数分析</a></li></ul></li><li><a href="/virtual/003_volatile.html" class="sidebar-link">学习volatile关键字</a></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="一、-gc需要完成的3件事"><a href="#一、-gc需要完成的3件事" aria-hidden="true" class="header-anchor">#</a> 一、 GC需要完成的3件事</h2> <div class="language- extra-class"><pre><code>1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收	
</code></pre></div><h2 id="二、java内存运行时区域的各个部分"><a href="#二、java内存运行时区域的各个部分" aria-hidden="true" class="header-anchor">#</a> 二、java内存运行时区域的各个部分</h2> <ol><li><p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出进行着出栈和入栈操作。每个栈帧中分配多少内存基本上是在类结构确定下来时就是已知的，因此这几个区域的内存分配和回收都具备确定性，不需要多考虑回收问题</p></li> <li><p>java堆和方法区需要考虑回收问题，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，只有在程序处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的</p></li></ol> <h2 id="三、引用计数算法"><a href="#三、引用计数算法" aria-hidden="true" class="header-anchor">#</a> 三、引用计数算法</h2> <ol><li><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象是不可能被引用的</p></li> <li><p>主流的java虚拟机里面没有选用引用计数算法来管理内存，其中主要原因是它很难解决对象之间相互循环引用的问题</p></li></ol> <h2 id="四、可达性算法"><a href="#四、可达性算法" aria-hidden="true" class="header-anchor">#</a> 四、可达性算法</h2> <ol><li>算法的基本思想就是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说就是从GC Roots到这个对象不可达）时，证明这个对象是不可用的</li></ol> <p><a data-fancybox="" title="可达性算法" href="/pic/aboutjava/UV8UeIZ.png"><img src="/pic/aboutjava/UV8UeIZ.png" alt="可达性算法"></a></p> <ol start="2"><li>在java语言中，可作为GCRoots的对象包括下面几种：
<ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li> <li>方法区中类静态属性引用的对象</li> <li>方法区中常量引用的对象</li> <li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ol></li></ol> <h2 id="五、引用"><a href="#五、引用" aria-hidden="true" class="header-anchor">#</a> 五、引用</h2> <ol><li><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判断对象都与‘引用’有关</p></li> <li><p>在JDK 1.2 之后，java对引用概念进行扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次减弱</p> <ol><li><p>强引用就是指程序代码中普遍存在的，类似‘Object obj = new Object();’这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象</p></li> <li><p>软引用，用来描述一些还有用但并非必需的对象，对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用</p></li> <li><p>弱引用也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次回收垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDLK1.2之后，提供了WeakReference类来实现弱引用</p></li> <li><p>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能够在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用</p></li></ol></li></ol> <h2 id="六、生存还是死亡"><a href="#六、生存还是死亡" aria-hidden="true" class="header-anchor">#</a> 六、生存还是死亡</h2> <p>即使在可达性分析算法中不可达的对象，也并非是‘非死不可的’，这时候它们暂时处于‘缓刑’阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过了，虚拟机将这两种情况都视为‘没有必要执行’</p> <p>如果这个对象被判为有必要执行finalize()方法，那么这个对象将会被放置在一个叫做F-Queue的队列中，并且稍后由一个虚拟机自动建立的，低优先级的Finalizer线程去执行它。这里的执行是指虚拟机会触发这个方法，但是并不承诺会等待它运行结束，这样的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环，将会导致F-Queue队列中其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。</p> <p>finalize()方法是对象逃离死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己-只要重新与引用链上的任何一个对象建立关联即可，例如把自己(this关键字)赋值给某个类变量或者对象成员变量，那么第二次标记它将被移除出‘即将回收’的集合；如果一个对象这时候还没有逃脱，那么基本上他就真的被回收了</p> <h2 id="七、回收方法区"><a href="#七、回收方法区" aria-hidden="true" class="header-anchor">#</a> 七、回收方法区</h2> <ol><li><p>Java虚拟机规范中说过可以不要求虚拟机在方法区中实现垃圾收集，而且在方法中进行垃圾收集的‘性价比’一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%空间，而永久代的垃圾收集效率远低于此</p></li> <li><p>永久代的垃圾收集主要收集两部分：废弃常量和无用的类。回收废弃常量与回收java堆中的对象非常相似。以常量池中字面量的回收为例，例如一个字符串‘abc’已经进入常量池中，但是当前系统中没有任何一个String对象是叫做‘abc’的，也就是没有任何String对象引用常量池中的‘abc’常量，也没有其他地方法引用了这个字面量，如果这时发生了内存回收，而且必要的话，这个‘abc’常量会被系统清理出常量池。常量池中的其它类（接口）、方法、字段的符号引用也如此</p></li> <li><p>判断一个常量是否是‘废弃常量’比较简单，但是判定一个类是否是‘无用的类’的条件比较刻薄，要满足以下条件</p> <ol><li>该类的所有实例都已经被回收，也就是java堆中不存在改类的任何实例</li> <li>加载该类的ClassLoader已经被回收</li> <li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ol></li> <li><p>虚拟机可以对满足上述3个条件的无用类进行回收，只是可以，并不是和对象一样，不使用了就必然会回收</p></li></ol> <h2 id="八、-垃圾收集算法"><a href="#八、-垃圾收集算法" aria-hidden="true" class="header-anchor">#</a> 八、 垃圾收集算法</h2> <h3 id="_1-标记-清除算法"><a href="#_1-标记-清除算法" aria-hidden="true" class="header-anchor">#</a> 1. 标记-清除算法</h3> <p>该算法分为 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段：首先标记出所有需要回收的对象，在标记完成之后统一回收所有被标记的对象。</p> <blockquote><p>该算法主要由两处不足：一是 <strong>效率问题</strong> ，标记和清除两个过程的效率都不高；另一个是<strong>空间问题</strong>，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</p></blockquote> <p><a data-fancybox="" title="标记-清除算法" href="/pic/aboutjava/hZcyjI3.jpg"><img src="/pic/aboutjava/hZcyjI3.jpg" alt="标记-清除算法"></a></p> <h3 id="_2-复制算法"><a href="#_2-复制算法" aria-hidden="true" class="header-anchor">#</a> 2. 复制算法</h3> <p>该算法将可用内存按容量划分大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将这还存活这的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可， 实现简单，运行高效</p> <p><a data-fancybox="" title="复制算法" href="/pic/aboutjava/K6pCb3p.jpg"><img src="/pic/aboutjava/K6pCb3p.jpg" alt="复制算法"></a></p> <blockquote><p>现在的商业虚拟都采用这种收集算法来回收<strong>新生代</strong>，IBM公司的专门研究表明，新生代中的对象98%是‘朝生夕死’的，所以并不需要按照1：1的比例来划分内存空间，而将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清除掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例为8：1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被‘浪费’。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担当（Handle Promotion）</p></blockquote> <h3 id="_3-标记-整理算法"><a href="#_3-标记-整理算法" aria-hidden="true" class="header-anchor">#</a> 3.标记-整理算法</h3> <p><strong>复制收集算法</strong>在对象存活率较高时就要进行较多的复制操作，效率会变低。更关键的时，如果不想浪费50%空间，就需要有额外的空间进行分配担当，以保证应对被使用的内存中所有对象都100%存活的极端情况，因此在老年代一般不能直接选用这种算法</p> <p>根据老年代的特点，提出了<strong>标记-整理算法</strong>，标记过程与‘标记-清除’算法一样，但是后续步骤是让所有存活的对象都向一端移动，然后直接清除掉边界之外的内存</p> <p><a data-fancybox="" title="标记-整理算法" href="/pic/aboutjava/1GYyHFn.jpg"><img src="/pic/aboutjava/1GYyHFn.jpg" alt="标记-整理算法"></a></p> <h2 id="九、分代收集算法"><a href="#九、分代收集算法" aria-hidden="true" class="header-anchor">#</a> 九、	分代收集算法</h2> <p>当前的商业虚拟机的垃圾收集都采用**‘分代收集(Generational Collection)’算法**，根据对象存活周期的不同将内存划分为几块。一般是分为 <strong>新生代</strong> 和 <strong>老年代</strong> ，这样就可以根据各个年代的特点采用最适当的收集算法。</p> <p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少数存活，那就选用复制算法，只需付出少量存活对象的复制成本就可以完成收集</p> <p>老年代中对象存活率高，没有额外空间对他进行分配担当，就必须使用 <strong>标记-清理</strong> 或者<strong>标记-整理</strong> 算法进行回收</p> <h2 id="十、垃圾收集器"><a href="#十、垃圾收集器" aria-hidden="true" class="header-anchor">#</a> 十、垃圾收集器</h2> <h4 id="基于jdk1-7-update-14之后的hotspot虚拟机"><a href="#基于jdk1-7-update-14之后的hotspot虚拟机" aria-hidden="true" class="header-anchor">#</a> 基于JDK1.7 Update 14之后的HotSpot虚拟机</h4> <p><a data-fancybox="" title="垃圾收集器" href="/pic/aboutjava/ncQCK4F.jpg"><img src="/pic/aboutjava/ncQCK4F.jpg" alt="垃圾收集器"></a></p> <h3 id="_1-serial收集器"><a href="#_1-serial收集器" aria-hidden="true" class="header-anchor">#</a> 1. Serial收集器</h3> <p><strong>运行时过程</strong>：新生代采用<strong>复制算法</strong>，暂停所有用户线程 ,老年代采用<strong>标记-整理算法</strong>，暂停所有用户线程</p> <p><a data-fancybox="" title="Serial收集器" href="/pic/aboutjava/UJCeRGB.jpg"><img src="/pic/aboutjava/UJCeRGB.jpg" alt="Serial收集器"></a></p> <p>Serial收集器依然虚拟机运行在Client模式下的<strong>默认新生代收集器</strong></p> <p>与其他收集器比较优点在于： <strong>简单而高效</strong>（在单线程情况下）,对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集器自然可以获得最高的单线程收集效率</p> <h3 id="_2-parnew收集器"><a href="#_2-parnew收集器" aria-hidden="true" class="header-anchor">#</a> 2. ParNew收集器</h3> <p><strong>运行时</strong></p> <p><a data-fancybox="" title="ParNew收集器" href="/pic/aboutjava/bas8RIg.jpg"><img src="/pic/aboutjava/bas8RIg.jpg" alt="ParNew收集器"></a></p> <p>ParNew收集器就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与Serial收集器完全一样</p> <p><strong>除了Serial收集器以外，只有ParNew收集器可以与CMS收集器配合工作</strong></p> <h3 id="_3-parallel-scavenge-收集器"><a href="#_3-parallel-scavenge-收集器" aria-hidden="true" class="header-anchor">#</a> 3. Parallel Scavenge 收集器</h3> <p>Parallel Scavenge收集器的特点在于它的关注点与其他收集器不一样，CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程停顿的时间，而Parallel Scavenge收集器地目标是<strong>达到一个可控制地吞吐量(Throughput)</strong>。所谓的吞吐量就是<strong>CPU用于运行用户代码的时间与CPU总消耗时间的比值</strong>，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）</p> <p>停顿时间越短越适合需要与用户交互的程序，良好的响应速度能够提升用户体验。而高吞吐量则可以高效率地利用CPU时间，尽可能完成程序的运算任务，主要适合在后台运算而不需要太多交互任务</p> <h3 id="_4-serial-old-收集器"><a href="#_4-serial-old-收集器" aria-hidden="true" class="header-anchor">#</a> 4.  Serial Old 收集器</h3> <p>Serial Old 收集器是<strong>Serial收集器的老年代版本</strong>，同样是一个单线程收集器, 使用 <strong>标记-整理</strong> 算法.</p> <p>这个收集器的主要意义在于给Client模式下的虚拟机使用。</p> <p>如果在Server模式下，还有两大用途：
在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用
作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用</p> <h3 id="_5-parallel-old-收集器"><a href="#_5-parallel-old-收集器" aria-hidden="true" class="header-anchor">#</a> 5.  Parallel Old 收集器</h3> <p>Parallel Old 收集器是<strong>Parallel Scavenge 收集器的老年版本</strong>，使用<strong>多线程和标记-整理算法</strong></p> <h3 id="_6-cms收集器"><a href="#_6-cms收集器" aria-hidden="true" class="header-anchor">#</a> 6. CMS收集器</h3> <p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器</p> <p>算法基于<strong>标记-清除</strong></p> <p>运行步骤为：</p> <ol><li><p>初始标记（CMS initial mark）</p></li> <li><p>并发标记（CMS concurrent mark）</p></li> <li><p>重新标记 (CMS remark)</p></li> <li><p>并发清除（CMS concurrent sweep）</p></li></ol> <ul><li><p>其中，初始标记，重新标记这两个步骤仍需要暂停用户进程。初始标记仅仅是标记一下GC Root能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing(可达性算法分析)的过程，而重新标记则是为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长些，但远比并发标记的时间短</p></li> <li><p>由于整个过程中耗时最长的并发标识和并发清除过程收集线程都可以与用户线程一起工作，所以，总的来说，CMS收集器的内存回收过程是与用于线程一起并发执行的</p></li></ul> <p><a data-fancybox="" title="CMS收集器" href="/pic/aboutjava/guk85ia.jpg"><img src="/pic/aboutjava/guk85ia.jpg" alt="CMS收集器"></a></p> <h3 id="_7-g1收集器"><a href="#_7-g1收集器" aria-hidden="true" class="header-anchor">#</a> 7. G1收集器</h3> <p>G1（Garbage-First）收集器是当今收集器技术发展最前沿成果之一，是一款面向服务端应用的垃圾收集器</p> <ul><li>与其他收集器相比，优点在于：</li></ul> <ol><li><p><strong>并行与并发</strong>。G1能够充分利用多CPU，多核环境下的硬件有时，使用多个CPU（CPU或者CPU核心）来缩短用户暂停时间，其他部分收集器原本需要停顿java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行</p></li> <li><p><strong>分代收集</strong>。与其他收集器一样，分代概念在G1中依然保留。虽然G1可以不需要其他收集器配合就可以独立管理整个GC堆，但是它能采用不同的方式去处理新创建的对象和已经存活一段时间，熬过多次GC的旧对象以获取更好的收集效果</p></li> <li><p><strong>空间整合</strong>。与CMS的‘标记-清理’算法不用，G1从整体来看是基于‘标记-整理’算法实现的收集器，从局部（两个Region之间）上来看是基于‘复制’算法实现的，但无论如何，这两种算法都G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提高触发下一次GC</p></li> <li><p><strong>可预测的停顿</strong></p></li></ol> <ul><li><p>G1 收集器的运行大致可以分为：</p> <ol><li><p><strong>初始标记（Initial Marking）</strong></p></li> <li><p><strong>并发标记（Concurrent Marking）</strong></p></li> <li><p><strong>最终标记（Final Marking）</strong></p></li> <li><p><strong>筛选回收（Live Data Counting and Evacuation）</strong></p> <p><strong>初始标识阶段</strong>仅仅是标记以下GC Roots能直接关联到的对象，并修改TAMS(Next Top at Mark Start)的值，让下一个阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</p> <p><strong>并发标记阶段</strong>是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。</p> <p><strong>最终标记阶段</strong>则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行</p> <p><strong>最后在筛选回收阶段</strong>首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划</p></li></ol></li></ul> <p><a data-fancybox="" title="G1收集器" href="/pic/aboutjava/oNVAdx4.jpg"><img src="/pic/aboutjava/oNVAdx4.jpg" alt="G1收集器"></a></p> <h2 id="十一、内存分配与回收策略"><a href="#十一、内存分配与回收策略" aria-hidden="true" class="header-anchor">#</a> 十一、内存分配与回收策略</h2> <ul><li><p><strong>对象的内存分配</strong>，往大方向讲，就是在堆上分配（但可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象主要分配在新生代地Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB（线程共享地java堆中可能划分出多个线程私有的分配缓冲区-Thread Local Allocation Buffer，TLAB）上分配。</p></li> <li><p><strong>内存分配策略</strong></p> <ol><li><p><strong>对象优先在Eden分配</strong>。大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC(从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC)</p></li> <li><p><strong>大对象直接进入老年代</strong>。所谓的大对象指的是需要大量连续内存空间的对象，最典型的大对象就是那种很长的字符串以及数数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间就提前触发垃圾收集以获取足够的连续空间来“安置”它们</p></li> <li><p><strong>长期存活的对象将进入老年代</strong>.既然虚拟机采用了分代收集的思想来管理内存，那么内存回收就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在Eden出生并经过第一次Minor GC 后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当他的年龄增加到一定程度（默认15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阙值，可以通过参数-XX:MaxTenuringThreshold设置</p></li> <li><p><strong>动态对象年龄判定</strong>。为了更好的适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄</p></li> <li><p><strong>空间分配担保</strong>。在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，那么会继续检查老年代最大可用的连续空间是否大于晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的，如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC</p></li></ol></li></ul> <h2 id="十二、gc日志理解"><a href="#十二、gc日志理解" aria-hidden="true" class="header-anchor">#</a> 十二、GC日志理解</h2> <blockquote><p>33.125：[GC [DefNew: 3324K -&gt; 152K (3712K), 0.0025925 secs] 3324K -&gt; 152K (11940K), 0.0031680 secs]</p> <p>100.667: [Full GC [Tenured: 0K -&gt; 210K (1024K), 0.0149142 secs] 4603K -&gt; 210K (19456K), [Perm: 2999 K -&gt; 2999K (21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</p></blockquote> <ul><li><p>最前面的数字“33.125：”和“100.667”：代表发生GC发生的时间，这个数字的含义是从java虚拟机启动以来经过的秒数</p></li> <li><p>GC日志开头的“ [GC ” 和 “[ Full GC ” 说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC 还是老年代GC的。如果有“Full”，说明这次GC发生了Stop-The-World的（暂停用户线程）。</p> <p>例如：</p></li></ul> <blockquote><p>[Full GC 283.736: [ParNew: 261599K -&gt; 261599K (261952K), 0.0000288 secs]</p></blockquote> <p>上面的这段新生代收集器ParNew的日志也会出现“[ Full GC ”(这一般是因为出现了分配担保失败之类的问题，这才导致STW)。如果是调用System.gc()方法所触发的收集，那么这里将显示“[Full GC(System)]”</p> <ul><li><p>“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的</p> <ol><li><p>例如上面的日志所有使用的Serial收集器的新生代名为“Default New Generation”，所显示的是“[DefNew”。</p></li> <li><p>如果是ParNew收集器，新生代名称就会变为“[ParNew”,意为“Parallel New Generation”。</p></li> <li><p>如果是采用Parallel Scavenge收集器，那么它配套的新生代称为“PSYoungGen”</p></li> <li><p>老年代和永久代同理，名字也是由收集器决定的</p></li></ol></li> <li><p>“3324K -&gt; 152K (3712K)” 含义是“GC前该内存区域已使用容量 ——&gt; GC后该内存区域已使用容量（该内存的总容量）”</p> <ol start="5"><li><p>在括号外的“ 3324K -&gt; 152K (11940K)” 表示“GC前Java堆已使用容量 ——&gt; GC后java堆已使用的容量（Java堆容量）”</p></li> <li><p>“0.0025925 secs” 表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times: user=0.01 sys=0.00, real=0.02 secs]”,这里面的user，sys和real与Liunx的time命令所输出的时间含义一致，分别代表了用户态消耗的CPU时间，内核态消耗的CPU事件和操作从开始到结束的所经过的墙钟事件（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间</p></li></ol></li></ul> <h2 id="十三、虚拟机参数分析"><a href="#十三、虚拟机参数分析" aria-hidden="true" class="header-anchor">#</a> 十三、虚拟机参数分析</h2> <table><thead><tr><th>参数名称</th> <th>含义</th> <th>默认值</th> <th style="text-align:left;"></th></tr></thead> <tbody><tr><td>-Xms</td> <td>初始队大小</td> <td>物理内存的1/64（&lt; 1GB）</td> <td style="text-align:left;">默认（MinHeapFreeRatio参数可以调整）空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制</td></tr> <tr><td>-Xmx</td> <td>最大堆大小</td> <td>物理内存的1/4(&lt;1GB)</td> <td style="text-align:left;">默认（NaxHeapFreeRatio参数可以调整）空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制</td></tr> <tr><td>-Xmn</td> <td>年轻代大小（1.4 or lator）</td> <td>此处大小是（eden+2survivor space）与jmap -heap中显示的New gen 是不用的，整个堆大小=年轻代代销+年老代大小+持久代大小，增加年轻代大小后，将会减少年老代大小，此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8</td> <td style="text-align:left;"></td></tr> <tr><td>-XX:NewSize</td> <td>设置年轻代大小(for 1.3/1.4)</td> <td></td> <td style="text-align:left;"></td></tr> <tr><td>-XX:MaxNewSize</td> <td>年轻代最大值(for 1.3/1.4)</td> <td></td> <td style="text-align:left;"></td></tr> <tr><td>-XX:PermSize</td> <td>设置持久代(perm gen)初始值</td> <td>物理内存的1/64</td> <td style="text-align:left;"></td></tr> <tr><td>-XX:MaxPermSize</td> <td>设置持久代最大值</td> <td>物理内存的1/4</td> <td style="text-align:left;"></td></tr> <tr><td>-Xss</td> <td>每个线程的堆栈大小</td> <td></td> <td style="text-align:left;">JDK5.0之后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K，更具应用的线程所需内存大小进行调整，在相同物理内存下，减少这个值能生成更多的线程，但是操作系统对一个进程内的线程数量还是有限制的，不能无限生成，经验值在3000~5000左右。一般小的应用，如果栈不是很深，应该是128K够用的，大的应用建议256K,这个选项对性能影响比较大，需要严格进行测试</td></tr> <tr><td>-XX:MaxTenuringThreshold</td> <td>垃圾最大年龄</td> <td></td> <td style="text-align:left;">如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率。该参数只有在串行GC时才有效.</td></tr></tbody></table></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/virtual/001_jvmmemoryarea.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        java内存区域
      </a></span> <span class="next"><a href="/virtual/003_volatile.html">
        学习volatile关键字
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.193c9b61.js" defer></script><script src="/assets/js/2.be286493.js" defer></script><script src="/assets/js/66.3db4dcf7.js" defer></script>
  </body>
</html>