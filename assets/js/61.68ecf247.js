(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{859:function(a,r,t){"use strict";t.r(r);var e=t(115),s=Object(e.a)({},function(){var a=this,r=a.$createElement,t=a._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"什么是fastdfs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是fastdfs","aria-hidden":"true"}},[a._v("#")]),a._v(" 什么是FastDFS")]),a._v(" "),t("p",[a._v("       FastDFS是一个开源的轻量级分布式文件系统，解决了大数据量存储和负载均衡等问题，特别适合以中小文件（建议范围：4KB<file_size<500MB ）为载体的在线服务，如相册网站，视频网站等等，在UC基于FastDFS开发向用户提供了：网盘，社区，广告和应用下载等业务的存储服务"),t("br"),a._v("\nFastDFS是一款开源的轻量级分布式文件系统纯C实现，支持Liunx、FreeBSD等UNIX系统类goole FS，不是通用的文件系统，只能通过专有API访问，目前提供了C、java和php API为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展FastDFS可以看做基于文件的key value pair存储系统，称作分布式文件存储服务更为合适")]),a._v(" "),t("h2",{attrs:{id:"fastdfs特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fastdfs特性","aria-hidden":"true"}},[a._v("#")]),a._v(" FastDFS特性")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("○ 文件不分块存储，上传的文件和OS文件系统中的文件一一对应\n○ 支持相同内容的文件只保存一份，节约磁盘空间\n○ 下载文件支持HTTP协议，可以使用内置WebServer，也可以和其他Web Server配合使用\n○ 支持在线扩容\n○ 支持主从文件\n○ 存储服务器上可以保存文件属性（meta-data）V2.0网络通信采用libevent，支持大并发访问，整体性能更好\n")])])]),t("h2",{attrs:{id:"fastdfs相关概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fastdfs相关概念","aria-hidden":"true"}},[a._v("#")]),a._v(" FastDFS相关概念")]),a._v(" "),t("p",[a._v("FastDFS服务端有三个角色："),t("em",[t("strong",[a._v("跟踪服务器（tracker  server）")])]),a._v(" 、"),t("em",[t("strong",[a._v("存储服务器（storage server）")])]),a._v(" 和 "),t("em",[t("strong",[a._v("客户端（client）")])])]),a._v(" "),t("ul",[t("li",[t("p",[t("em",[t("strong",[a._v("tracker server")])]),a._v("：跟踪服务器，主要做调用工作，起负载均衡的作用，在内存中记录集群中所有存储组和存储服务器的状态信息，是客户端和数据服务器交互的枢纽，相比GFS中master更为精简，不记录文件索引信息，占用的内存量很少."),t("br"),a._v("\n       Tracker是FastDFS的协调者，负责管理所有的storage server和group，每个storage在启动后会连接Tracker，告知自己所属的group等信息，并保持周期性的心跳，tracker根据storage的心跳信息，建立group=>[storage server list]的映射表."),t("br"),a._v("\n       Tracker需要管理的元信息很少，会全部存储在内存中；另外tracker上的元信息都是由storage汇报的信息生成的，本身不需要持久化任何数据，这样使得tracker非常容易扩展，直接增加tracker机器即可扩展为tracker cluster来服务，cluster里每个tracker之间是完成对等的，所有的tracker都接收storage的心跳信息，生成元数据信息来提供读写服务.")])]),a._v(" "),t("li",[t("p",[t("em",[t("strong",[a._v("storage server")])]),a._v("：存储服务器（又称为存储节点或数据服务器），文件和文件属性（meta data）都保存到存储服务器上，Storage server直接利用OS的文件系统调用管理文件."),t("br"),a._v("\n       Storage Server（简称storage）以组（卷，group或volume）为单位组织，一个group内包含多台storage机器，数据互为备份，存储空间以group内容量最小的storage为准，所以建议group内的多个storage尽量配置相同，以免造成存储空间的浪费."),t("br"),a._v("\n以group为单位组织存储能方便进行应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数），比如将不同应用数据存到不同的group就能隔离应用数据，同时还可根据应用的访问特性来将应用分配到不同的group来做负载均衡；缺点是group的容量受单机存储容量的限制，同时当group内有机器坏掉时，数据恢复只能依赖group内其他机器，使得恢复时间很长."),t("br"),a._v("\n       group内每个storage的存储依赖于本地文件系统，storage可配置多个数据存储目录，比如有10块磁盘，分别挂载在/data/disk1-/data/disk10，则可将这10个目录都配置为storage的数据存储目录."),t("br"),a._v("\n       storage接收到写文件请求时，会根据配置好的规则，选择其中一个存储目录来存储文件，为了避免单个目录下的文件数太多，在storage第一次启动时，会在每个数据存储目录里创建2级目录，每级256个，总共6553个文件，新写的文件会以hash的方式被路由到其中某个子目录下，然后将文件数据直接作一个本地文件存储到该目录下.")])]),a._v(" "),t("li",[t("p",[t("em",[t("strong",[a._v("client")])]),a._v("：客户端，作为业务请求的发起方，通过专有接口，使用TCP/IP协议与跟踪服务器或存储节点进行数据交互，FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用.")])]),a._v(" "),t("li",[t("p",[t("em",[t("strong",[a._v("group")])]),a._v("：组，也可称为卷。同组内服务器上的文件是完全相同的，同一组内的storage server之间是对等的，文件上传，删除操作可以在任意一台storage server进行.")])]),a._v(" "),t("li",[t("p",[t("em",[t("strong",[a._v("meta data")])]),a._v("：文件相关属性，键值对（Key Value Pair）方式，比如：width=1024，heigth=768.")])])]),a._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"FastDFS服务端",href:"/pic/aboutjava/fastdfs_001.jpg"}},[t("img",{attrs:{src:"/pic/aboutjava/fastdfs_001.jpg",alt:"FastDFS服务端"}})])]),a._v(" "),t("blockquote",[t("p",[a._v("Tracker相当于FastDFS的大脑，不论是上传还是下载都是通过tracker来分配资源；客户端一般可以使用ngnix等静态服务器来调用或做一部分的缓存；存储服务器内部分为卷（或者叫做组），卷与卷之间是平行关系，可以根据资源的使用情况随时增加，卷内服务器文件相互同步备份，以达到容灾的目的")])]),a._v(" "),t("h2",{attrs:{id:"上传机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#上传机制","aria-hidden":"true"}},[a._v("#")]),a._v(" 上传机制")]),a._v(" "),t("p",[a._v("首先客户端请求tracker服务获取到存储服务器的ip地址和端口，然后客户端根据返回的ip地址和端口号请求上传文件，存储服务器接收到请求后生产文件，并且将文件内容写入磁盘并返回给客户端file_id、路径信息、文件名等信息，客户端保存相关信息上传完毕")]),a._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"上传机制",href:"/pic/aboutjava/fastdfs_002.jpg"}},[t("img",{attrs:{src:"/pic/aboutjava/fastdfs_002.jpg",alt:"上传机制"}})])]),a._v(" "),t("h2",{attrs:{id:"内部机制如下："}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内部机制如下：","aria-hidden":"true"}},[a._v("#")]),a._v(" 内部机制如下：")]),a._v(" "),t("ul",[t("li",[t("ol",[t("li",[t("em",[t("strong",[a._v("选择tracker server")])])])]),a._v(" "),t("p",[a._v("当集群中不止一个tracker server时，由于tracker之间是完全对等的关系，客户端在upload文件时可以任意选择一个tracker。选择存储的group，当tracker接收到upload file的请求时，会为该文件分配一个可以存储该文件的group，支持如下选择group的规则：\na. Round robin：所有的group间轮询\nb. Specified group：指定某一个确定的group\nc. Load balance：剩余存储空间多，多的group优先")])]),a._v(" "),t("li",[t("ol",{attrs:{start:"2"}},[t("li",[t("em",[t("strong",[a._v("选择storage server")])])])]),a._v(" "),t("p",[a._v("当选定group之后，tracker会在group内选择一个storage server给客户端，支持如下选择storage的规则：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("a. Round robin：在group内的所有storage间轮询\nb. First server ordered by ip：按ip排序\nc. First server ordered by priority：按优先级排序（优先级在storage上配置）\n")])])])]),a._v(" "),t("li",[t("ol",{attrs:{start:"3"}},[t("li",[t("em",[t("strong",[a._v("选择storage path")])])])]),a._v(" "),t("p",[a._v("当分配好storage server后，客户端将向storage发送写文件的请求，storage将会为文件分配一个数据存储目录，支持规则如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v(" a. Round robin：多个存储目录间轮询\n b. 剩余存储空间最多的优先\n")])])])]),a._v(" "),t("li",[t("ol",{attrs:{start:"4"}},[t("li",[t("em",[t("strong",[a._v("生产file id")])])])]),a._v(" "),t("p",[a._v("选定存储目录之后，storage会为文件生成一个fileid，由storage server ip、文件创建时间、文件大小、文件crc32和一个随机数拼接而成，然后将这个二进制串践行base64编码，转换成可打印的字符串，选择两级目录当选定存储目录之后，storage会为文件分配一个fileid，每个存储目录下有两级256*256的子目录，storage会按文件fileid进行两次hash(猜测)，路由到其中一个子目录，然后将文件一个fileId为文件名存储到该子目录下")])]),a._v(" "),t("li",[t("ol",{attrs:{start:"5"}},[t("li",[t("em",[t("strong",[a._v("生成文件名")])])])]),a._v(" "),t("p",[a._v("当文件存储到某个子目录后，即认为该文件存储成功，接下来会为该文件生成一个文件名，文件名由group、存储目录、两级子目录、filedId、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成")])])]),a._v(" "),t("h2",{attrs:{id:"下载机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#下载机制","aria-hidden":"true"}},[a._v("#")]),a._v(" 下载机制")]),a._v(" "),t("p",[a._v("客户端带上文件名信息请求Tracker服务获取到存储服务器的ip地址和端口，然后客户端根据返回的IP地址和端口请求下载文件，存储服务器接收到请求后返回文件给客户端")]),a._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"下载机制",href:"/pic/aboutjava/fastdfs_003.jpg"}},[t("img",{attrs:{src:"/pic/aboutjava/fastdfs_003.jpg",alt:"下载机制"}})])]),a._v(" "),t("p",[a._v("       跟upload file一样，在download file时客户端可以选择任意tracker server。tracker发送download请求给某个tracker，必须带上文件名信息，tracke从文件名中解析出文件的group、大小、创建时间等信息，然后为该请求选择一个storage用来服务读请求，由于group内的文件同步是在后台异步进行的，所以有可能出现在读到时候，文件还没有同步到某些storage server上，为了尽量避免访问到这样的storage，tracker按照如下规则选择group内可读的storage")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("1. 该文件上传到的源头storage-源头storage只要存活着，肯定包含这个文件，源头的地址被编码在文件名中\n2. 文件创建时间戳 == storage被同步到的时间戳 且（当前时间-文件创建时间戳）> 文件同步最大时间（如5分钟） - 文件创建后，认为经过最大同步时间后，肯定已经同步到其他storage了。\n3. 文件创建时间戳 < storage被同步到的时间戳。 - 同步时间戳之前的文件确定已经同步\n4. （当前时间-文件创建时间戳）> 同步延迟阈值（如一天）。经过同步延迟阈值时间，认为文件肯定已经同步\n")])])]),t("h2",{attrs:{id:"同步时间管理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步时间管理","aria-hidden":"true"}},[a._v("#")]),a._v(" 同步时间管理")]),a._v(" "),t("p",[a._v("当一个文件上传成功后，客户端马上发起对该文件下载请求（或删除请求）时，tracker是如何选定一个适合的存储服务器呢？其实每个存储服务器都需要定时将自身的信息上报给tracker，这些信息就包括了本地同步时间（即同步到的最新文件时间戳）。而tracker根据各个存储服务器的上报情况，就能知道刚刚上传的文件，在该存储组中是否已完成同步，同步信息上报如下：")]),a._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"同步时间管理",href:"/pic/aboutjava/fastdfs_004.jpg"}},[t("img",{attrs:{src:"/pic/aboutjava/fastdfs_004.jpg",alt:"同步时间管理"}})])]),a._v(" "),t("p",[a._v("       写文件时，客户端将文件写至group内一个storage sever即认为写文件成功，storage server写完文件后，会由后台线程将文件同步到同group内其他的storage server"),t("br"),a._v("\n       每个storage写文件，同时会写一份binlog，binlog里不包含文件数据，只包含文件等元信息，这份binlog用于后台同步，storage会记录向group内其他storage同步的进度，以便重启后能接上上次的进度继续同步；进度以时间戳的方式进行记录，所以最好能保证集群内所有的server的时间保持同步"),t("br"),a._v("\n       storage的同步进度会作为元数据的一部分汇报到tracker上，tracker在选择读storage的时候会以同步进度作为参考。比如一个group内A、B、C三个storage server，A向C同步到进度为T1（T1以前写的文件都已经同步到B上了），B向C同步到时间戳为T2（T2>T1），tracker接收到这些同步进度信息时，就会进行整理，将最小的那个作为C的同步时间戳，本例中T1即为C的同步时间戳为T1(所有T1以前写的数据都已经同步到C上了)；同理，根据以上规则，tracker会为A，B生成一个同步时间戳")]),a._v(" "),t("h2",{attrs:{id:"精巧的文件id-fid"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#精巧的文件id-fid","aria-hidden":"true"}},[a._v("#")]),a._v(" 精巧的文件ID-FID")]),a._v(" "),t("p",[a._v("说到下载就不得不提文件索引（又称为：FID）的精巧设计了，文件索引结构如下图，是客户端上传文件后存储服务器返回给客户端，用于以后访问该文件的索引信息，文件索引信息包括：组名，虚拟磁盘路径，数据两级目录，文件名")]),a._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"FID",href:"/pic/aboutjava/fastdfs_005.jpg"}},[t("img",{attrs:{src:"/pic/aboutjava/fastdfs_005.jpg",alt:"FID"}})])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("• 组名：文件上传后所在的存储组名称，在文件上传成功后有存储服务器返回，需要客户端自行保存\n• 虚拟磁盘路径：存储服务器配置的虚拟路径，与磁盘选项store_path*对应\n• 数据两级目录：存储服务器在每个虚拟磁盘路径下创建的两级目录，用于存储数据文件\n• 文件名：与文件上传时不同，是由存储服务器根据特定信息生成的，文件名包含：源存储服务器IP地址，文件创建时间戳，文件大小，随机数和文件扩展名等信息\n")])])]),t("h2",{attrs:{id:"快速定位文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快速定位文件","aria-hidden":"true"}},[a._v("#")]),a._v(" 快速定位文件")]),a._v(" "),t("p",[a._v("知道FastDFS FID的组成后，是如何定位到需要访问的文件？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("1. 通过组名tracker能够很快的定位到客户端需要访问的存储服务器组，并将选择合适的存储服务器提供客户端访问\n2. 存储服务器根据“文件存储虚拟磁盘路径”和“数据文件两级目录”可以很快定位到文件所在目录，并根据文件名找到客户端需要访问的文件\n")])])]),t("p",[t("a",{attrs:{"data-fancybox":"",title:"快速定位文件",href:"/pic/aboutjava/fastdfs_006.jpg"}},[t("img",{attrs:{src:"/pic/aboutjava/fastdfs_006.jpg",alt:"快速定位文件"}})])]),a._v(" "),t("h2",{attrs:{id:"部署fastdfs分布式文件系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#部署fastdfs分布式文件系统","aria-hidden":"true"}},[a._v("#")]),a._v(" 部署FASTDFS分布式文件系统")]),a._v(" "),t("p",[t("a",{attrs:{"data-fancybox":"",title:"部署FASTDFS分布式文件系统",href:"/pic/aboutjava/fastdfs_007.jpg"}},[t("img",{attrs:{src:"/pic/aboutjava/fastdfs_007.jpg",alt:"部署FASTDFS分布式文件系统"}})])])])},[],!1,null,null,null);r.default=s.exports}}]);