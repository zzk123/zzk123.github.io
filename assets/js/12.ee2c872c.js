(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{812:function(t,e,n){"use strict";n.r(e);var r=n(115),l=Object(r.a)({},function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"定义"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#定义","aria-hidden":"true"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),n("p",[t._v("一棵二叉查找树（BST）是一棵二叉树，每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键且小于右子树的任意结点的键。")]),t._v(" "),n("h2",{attrs:{id:"实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[t._v("/**\n * 基于二叉树的符号表\n * @author zzk\n *\n */\npublic class BST<Key extends Comparable<Key>,Value> {\n\t\n\t//二叉树的根节点\n\tprivate Node root;\n\t\n\tprivate class Node{\n\t\t\n\t\tprivate Key key;\t\t\t//键\n\t\tprivate Value val;\t\t\t//值\n\t\tprivate Node left, right;\t//指向子树的链接\n\t\tprivate int N;\t\t\t\t//以该结点为根的子树中的结点总数\n\t\t\n\t\tpublic Node(Key key, Value val, int N){\n\t\t\tthis.key = key;\n\t\t\tthis.val = val;\n\t\t\tthis.N = N;\n\t\t}\n\t}\n\t\n\tpublic int size(){\n\t\treturn size(root);\n\t}\n\t\n\tprivate int size(Node x){\n\t\tif(x == null)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn x.N;\n\t}\n\t\n\tpublic Value get(Key key){\n\t\treturn get(root, key);\n\t}\n\n\t//在以x为根节点的子树中查找并返回key所对应的值\n\t//如果找不到则返回null\n\tprivate Value get(Node x, Key key){\n\t\tif(x==null)\n\t\t\treturn null;\n\t\tint cmp = key.compareTo(x.key);\n\t\tif( cmp<0 )\n\t\t\treturn get(x.left, key);\n\t\telse if( cmp>0 )\n\t\t\treturn get(x.right, key);\n\t\telse \n\t\t\treturn x.val;\n\t}\n\t\n\tpublic void put(Key key, Value val){\n\t\t//查找到key，找到就更新它的值，否则就创建一个新的节点\n\t\troot = put(root, key, val);\n\t}\n\t\n\tprivate Node put(Node x, Key key, Value val){\n\t\t//如果key存在于以x为根节点的子树中则更新它的值\n\t\t//否则将以key和val为键值对的新节点插入到该子树中\n\t\tif(x==null)\n\t\t\treturn new Node(key, val, 1);\n\t\tint cmp = key.compareTo(x.key);\n\t\tif(cmp < 0)\n\t\t\tx.left = put(x.left, key, val);\n\t\telse if( cmp > 0 )\n\t\t\tx.right = put(x.right, key, val);\n\t\telse \n\t\t\tx.val = val;\n\t\t//插入完成后更新长度\n\t\tx.N = size(x.left)+size(x.right)+1;\n\t\treturn x;\n\t}\n\n\t//最小值\n\tpublic Key min(){\n\t\treturn min(root).key;\n\t}\n\t//不断的进入左树查找\n\tprivate Node min(Node x){\n\t\tif(x.left == null)\n\t\t\treturn x;\n\t\treturn min(x.left);\n\t}\n\t\n\tpublic Key max(){\n\t\treturn max(root).key;\n\t}\n\t\n\tprivate Node max(Node x){\n\t\tif(x.right == null)\n\t\t\treturn x;\n\t\treturn max(x.right);\n\t}\n\t\n\t//小于等于key值的最大键（向下取整）\n\tpublic Key floor(Key key){\n\t\tNode x = floor(root, key);\n\t\tif(x == null)\n\t\t\treturn null;\n\t\treturn x.key;\n\t}\n\tprivate Node floor(Node x, Key key){\n\t\tif(x==null)\n\t\t\treturn null;\n\t\tint cmp = key.compareTo(x.key);\n\t\tif(cmp==0)\n\t\t\treturn x;\n\t\tif(cmp<0)\n\t\t\treturn floor(x.left, key);\n\t\tNode t = floor(x.right, key);\n\t\tif(t!=null)\n\t\t\treturn t;\n\t\telse\n\t\t\treturn x;\n\t}\n\t\n\t//返回给定键的排名（也就相当于在排序数组中查找某索引位置的值）\n\tpublic Key select(int k){\n\t\treturn select(root, k).key;\n\t}\n\t\n\tprivate Node select(Node x, int k){\n\t\t//返回排名为k的节点\n\t\tif(x==null){\n\t\t\treturn null;\n\t\t}\n\t\tint t = size(x.left);\n\t\tif(t>k)\n\t\t\treturn select(x.left, k);\n\t\telse if(t<k)\n\t\t\treturn select(x.right, k-t-1);\n\t\telse \n\t\t\treturn x;\n\t}\n\t\n\t//返回以x为根节点的子树中小于x.key的键的数量（也就相当于在排序数组中查找某值在数组中的索引）\n\tpublic int rank(Key key){\n\t\treturn rank(key, root);\n\t}\n\t\n\tprivate int rank(Key key, Node x){\n\t\t//返回以x为根节点的子树中小于x.key的键的数量\n\t\tif(x==null)\n\t\t\treturn 0;\n\t\tint cmp = key.compareTo(x.key);\n\t\tif(cmp < 0)\n\t\t\treturn rank(key, x.left);\n\t\telse if(cmp > 0 )\n\t\t\treturn 1+size(x.left) + rank(key, x.right);\n\t\telse\n\t\t\treturn size(x.left);\n\t}\n\t\n\t//删除最小值\n\tpublic void deleteMin(){\n\t\troot = deleteMin(root);\n\t}\n\t\n\tprivate Node deleteMin(Node x){\n\t\tif( x.left == null ){\n\t\t\treturn x.right;\n\t\t}\n\t\tx.left = deleteMin(x.left);\n\t\tx.N = size(x.left) + size(x.right) + 1;\n\t\treturn x;\n\t}\n\t//删除某键\n\tpublic void delete(Key key){\n\t\troot = delete(root, key);\n\t}\n\t//删除key值，删除后用key的后继节点填补它的位置\n\tprivate Node delete(Node x, Key key){\n\t\tif(x==null)\n\t\t\treturn null;\n\t\tint cmp = key.compareTo(x.key);\n\t\tif( cmp < 0 )\n\t\t\tx.left = delete(x.left, key);\n\t\telse if( cmp > 0 )\n\t\t\tx.right = delete(x.right, key);\n\t\telse{\n\t\t\tNode t = x;\n\t\t\tx = min(t.right);\n\t\t\tx.right  = deleteMin(t.right);\n\t\t\tx.left = t.left;\n\t\t}\n\t\tx.N = size(x.left) + size(x.right) + 1;\n\t\treturn x;\n\t}\n\t//中序遍历（左-根-右）\n\tprivate void print(Node x){\n\t\tif( x == null )\n\t\t\treturn;\n\t\tprint(x.left);\n\t\tStdOut.println(x.key);\n\t\tprint(x.right);\n\t}\n\t\n\t//二叉查找数的范围查找操作（查找出最小值到最大值之间的key集合）\n\tpublic Iterable<Key> keys(){\n\t\treturn keys(min(), max());\n\t}\n\t\n\tpublic Iterable<Key> keys(Key lo, Key hi){\n\t\tQueue<Key> queue = new Queue<Key>();\n\t\tkeys(root, queue, lo, hi);\n\t\treturn queue;\n\t}\n\t\n\tprivate void keys(Node x, Queue<Key> queue, Key lo, Key hi){\n\t\tif( x==null )\n\t\t\treturn;\n\t\tint cmplo = lo.compareTo(x.key);\n\t\tint cmphi = hi.compareTo(x.key);\n\t\tif(cmplo < 0)\n\t\t\tkeys(x.left, queue, lo, hi);\n\t\tif(cmplo <= 0 && cmphi >=0 )\n\t\t\tqueue.enqueue(x.key);\n\t\tif( cmphi > 0 )\n\t\t\tkeys(x.right, queue, lo, hi);\n\t}\n}\n")])])]),n("h2",{attrs:{id:"性能"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#性能","aria-hidden":"true"}},[t._v("#")]),t._v(" 性能")]),t._v(" "),n("p",[t._v("在一棵二叉查找树中，所有的操作在最坏情况下所需的时间都和树的高度成正比，树的所有操作都沿着树的一条或两条路径行进，根据定义树的长度不可能大于树的高度。")]),t._v(" "),n("h2",{attrs:{id:"简单的符号表实现成本"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#简单的符号表实现成本","aria-hidden":"true"}},[t._v("#")]),t._v(" 简单的符号表实现成本")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("算法（数据结构）")]),t._v(" "),n("th",[t._v("最坏的情况下的运行时间的增长数量级（N次插入之后）")]),t._v(" "),n("th",[t._v("-")]),t._v(" "),n("th",[t._v("平均情况下的运行时间的增长数量级（N次随机插入之后）")]),t._v(" "),n("th",[t._v("-")]),t._v(" "),n("th",{staticStyle:{"text-align":"left"}},[t._v("是否支持有序相关的操作")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("-")]),t._v(" "),n("td",[t._v("查找")]),t._v(" "),n("td",[t._v("插入")]),t._v(" "),n("td",[t._v("查找命中")]),t._v(" "),n("td",[t._v("插入")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("-")])]),t._v(" "),n("tr",[n("td",[t._v("顺序查询（无序链表）")]),t._v(" "),n("td",[t._v("N")]),t._v(" "),n("td",[t._v("N")]),t._v(" "),n("td",[t._v("N/2")]),t._v(" "),n("td",[t._v("N")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("否")])]),t._v(" "),n("tr",[n("td",[t._v("二分查找（有序数组）")]),t._v(" "),n("td",[t._v("lgN")]),t._v(" "),n("td",[t._v("N")]),t._v(" "),n("td",[t._v("lgN")]),t._v(" "),n("td",[t._v("N/2")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("是")])]),t._v(" "),n("tr",[n("td",[t._v("二叉树查找（二叉查找树）")]),t._v(" "),n("td",[t._v("N")]),t._v(" "),n("td",[t._v("N")]),t._v(" "),n("td",[t._v("1.39lgN")]),t._v(" "),n("td",[t._v("1.39lgN")]),t._v(" "),n("td",{staticStyle:{"text-align":"left"}},[t._v("是")])])])])])},[],!1,null,null,null);e.default=l.exports}}]);