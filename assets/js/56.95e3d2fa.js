(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{828:function(t,a,e){"use strict";e.r(a);var r=e(115),s=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"第六十六条：同步访问共享的可变数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第六十六条：同步访问共享的可变数据","aria-hidden":"true"}},[t._v("#")]),t._v(" 第六十六条：同步访问共享的可变数据")]),t._v(" "),e("blockquote",[e("p",[t._v("多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步，如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知。未能同步共享可变数据会造成程序的活性失败和安全性失败")])]),t._v(" "),e("h2",{attrs:{id:"第六十七条：避免过度同步"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第六十七条：避免过度同步","aria-hidden":"true"}},[t._v("#")]),t._v(" 第六十七条：避免过度同步")]),t._v(" "),e("blockquote",[e("p",[t._v("根据情况的不同，过度同步可能会导致性能降低、死锁，甚至不确定的行为。为了避免死锁和数据破坏，不要从同步区域调用外来方法。要尽量限制同步区域内部的工作量。当设计一个可变类的时候，要考虑一下他们是否应该自己完成同步操作")])]),t._v(" "),e("h2",{attrs:{id:"第六十八条：executor和task优先于线程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第六十八条：executor和task优先于线程","aria-hidden":"true"}},[t._v("#")]),t._v(" 第六十八条：executor和task优先于线程")]),t._v(" "),e("h2",{attrs:{id:"第六十九条：并发工具优先于wait和notify"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第六十九条：并发工具优先于wait和notify","aria-hidden":"true"}},[t._v("#")]),t._v(" 第六十九条：并发工具优先于wait和notify")]),t._v(" "),e("h2",{attrs:{id:"第七十条：线程安全性的文档化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第七十条：线程安全性的文档化","aria-hidden":"true"}},[t._v("#")]),t._v(" 第七十条：线程安全性的文档化")]),t._v(" "),e("h2",{attrs:{id:"第七十一条：慎用延迟初始化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第七十一条：慎用延迟初始化","aria-hidden":"true"}},[t._v("#")]),t._v(" 第七十一条：慎用延迟初始化")]),t._v(" "),e("blockquote",[e("p",[t._v("大多数的域应该正常的进行初始化，而不是延迟初始化。如果为了达到性能目标，或者为了破坏有害的初始化循环，而必须延迟初始化一个域，就可以使用相应的延迟初始化方法。对于实例域，就使用双重检查模式（double-check idiom）；对于静态域，则使用lazy initialization holder class idiom。对于可以接受重复初始化的实例域，也可以考虑使用单重检查模式（single-check idiom）")])]),t._v(" "),e("h2",{attrs:{id:"第七十二条：不要依赖于线程调度器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第七十二条：不要依赖于线程调度器","aria-hidden":"true"}},[t._v("#")]),t._v(" 第七十二条：不要依赖于线程调度器")]),t._v(" "),e("blockquote",[e("p",[t._v('当有多个线程可以运行时，由线程调度器（thread scheduler）决定哪些线程将会运行，以及运行多长时间。任何一个合理的操作系统在做出这样的决定时，都会努力做到公正，但是所采用的策略却大相径庭。因此，不要让应用程序的正确性依赖于线程调度器。否则得到的应用程序既不健壮，也不具有移植性。作为推论，不要依赖于Thread.yield或线程优先级。这些设施仅仅对调度器做些暗示；线程优先级可以用来提高一个已经能够正常工作的程序的服务质量，但是永远不应该用来"修正"一个原本并不能工作的程序')])]),t._v(" "),e("h2",{attrs:{id:"第七十三条：避免使用线程组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第七十三条：避免使用线程组","aria-hidden":"true"}},[t._v("#")]),t._v(" 第七十三条：避免使用线程组")])])},[],!1,null,null,null);a.default=s.exports}}]);