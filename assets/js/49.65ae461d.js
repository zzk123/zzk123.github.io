(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{822:function(a,e,t){"use strict";t.r(e);var s=t(115),r=Object(s.a)({},function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述","aria-hidden":"true"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),t("blockquote",[t("p",[a._v("尽管Object是一个具体类，但是设计它主要是为了扩展。它所有的非final方法（equals，hashCode，toString，clone和finalize）都有明确的通用约定（general contract），因为它们被设计成是要被覆盖的（override）。任何一个类，他在覆盖这些方法的时候，都有责任遵守这写通用约定，如果不能做到这一点，其他依赖于这些约定的类（如HashMap和HashSet），就无法结合该类一起正常运行")])]),a._v(" "),t("h2",{attrs:{id:"第八条：覆盖equals时请遵守通用约定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第八条：覆盖equals时请遵守通用约定","aria-hidden":"true"}},[a._v("#")]),a._v(" 第八条：覆盖equals时请遵守通用约定")]),a._v(" "),t("h3",{attrs:{id:"覆盖equals方法时候，要遵守的通用约定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#覆盖equals方法时候，要遵守的通用约定","aria-hidden":"true"}},[a._v("#")]),a._v(" 覆盖equals方法时候，要遵守的通用约定")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("自反性（reflexive）")]),a._v("：对于任何非null的引用值x，x.equals(x)必须返回true")]),a._v(" "),t("li",[t("strong",[a._v("对称性（symmetric）")]),a._v("：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true")]),a._v(" "),t("li",[t("strong",[a._v("传递性（transitive）")]),a._v("：对于任何非null的引用值x，y和z，如果x.equals(y)返回true，并且y.equals(z)也返回true，那么x.equals(z)也必须返回true")]),a._v(" "),t("li",[t("strong",[a._v("一致性（consistent）")]),a._v("：对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false")]),a._v(" "),t("li",[t("strong",[a._v("非空性（Non-nullity）")]),a._v("：对于任何非null的引用值x，x.equals(null)必须返回false")])]),a._v(" "),t("h2",{attrs:{id:"第九条：覆盖equals时总要覆盖hashcode"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第九条：覆盖equals时总要覆盖hashcode","aria-hidden":"true"}},[a._v("#")]),a._v(" 第九条：覆盖equals时总要覆盖hashCode")]),a._v(" "),t("blockquote",[t("p",[t("strong",[a._v("在每个覆盖了equals方法的类中，也必须覆盖hashCode方法")]),a._v("，如果不这样做的话，会违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运行，这样的集合包括HashMap，HashSet和HashTable")])]),a._v(" "),t("h3",{attrs:{id:"obect相关规范"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#obect相关规范","aria-hidden":"true"}},[a._v("#")]),a._v(" Obect相关规范")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致")])]),a._v(" "),t("li",[t("p",[a._v("如果每个对象根据equals（Object）方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果")])]),a._v(" "),t("li",[t("p",[a._v("如果两个对象根据equals（Object）方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生不同大的整数结果")])])]),a._v(" "),t("h2",{attrs:{id:"第十条：始终要覆盖tostring"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第十条：始终要覆盖tostring","aria-hidden":"true"}},[a._v("#")]),a._v(" 第十条：始终要覆盖toString")]),a._v(" "),t("h2",{attrs:{id:"第十一条：谨慎地覆盖clone"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第十一条：谨慎地覆盖clone","aria-hidden":"true"}},[a._v("#")]),a._v(" 第十一条：谨慎地覆盖clone")]),a._v(" "),t("h2",{attrs:{id:"第十二条：考虑实现comparable接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第十二条：考虑实现comparable接口","aria-hidden":"true"}},[a._v("#")]),a._v(" 第十二条：考虑实现Comparable接口")])])},[],!1,null,null,null);e.default=r.exports}}]);