(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{838:function(t,a,r){"use strict";r.r(a);var e=r(115),n=Object(e.a)({},function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"_2-3查找树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-3查找树","aria-hidden":"true"}},[t._v("#")]),t._v(" 2-3查找树")]),t._v(" "),r("h3",{attrs:{id:"定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定义","aria-hidden":"true"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),r("p",[t._v("一棵2-3查找树或为一棵空树，由以下结点组成：")]),t._v(" "),r("blockquote",[r("p",[t._v("2-结点，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右结点指向的2-3树中的键都大于该结点。"),r("br"),t._v("\n3-结点，含有两个键（及其对应的值）和三条链，左链接指向的2-3树中的键都小于该结点，中链接指向的2-3树中的键都位于该结点的两个键之间，右结点指向的2-3树中的键都大于该结点。"),r("br"),t._v("\n注：一棵完美平衡的2-3查找树中所有的空链接到根结点的距离应该都是相同的。")])]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"2-3查找树",href:"/pic/algorithm/MXG5Eil.png"}},[r("img",{attrs:{src:"/pic/algorithm/MXG5Eil.png",alt:"2-3查找树"}})])]),t._v(" "),r("h3",{attrs:{id:"基本操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本操作","aria-hidden":"true"}},[t._v("#")]),t._v(" 基本操作")]),t._v(" "),r("h4",{attrs:{id:"查找"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查找","aria-hidden":"true"}},[t._v("#")]),t._v(" 查找")]),t._v(" "),r("blockquote",[r("p",[t._v("要判断一个键是否存在树中，先将它和根结点中的键比较，如果它和其中任意一个相等，查找命中；否则我们就根据比较结果找到指定的区间的链接，并在其指向的子树中递归的继续查找，如果是空链接，查找未命中。")])]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"查找",href:"/pic/algorithm/nim0vYH.png"}},[r("img",{attrs:{src:"/pic/algorithm/nim0vYH.png",alt:"查找"}})])]),t._v(" "),r("blockquote",[r("p",[t._v("如上图对于H的查找命中，对于B的查找未命中")])]),t._v(" "),r("h4",{attrs:{id:"向2-结点中插入新键"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#向2-结点中插入新键","aria-hidden":"true"}},[t._v("#")]),t._v(" 向2-结点中插入新键")]),t._v(" "),r("blockquote",[r("p",[t._v("要在2-3树中插入一个新的结点，可以和查找二叉查找树一样先进行一次未命中查找，然后把新结点挂在树的底部，但是为了保证树的完美平衡性，要将2-结点替换成3-结点，将要插入的键保存于其中。"),r("br"),t._v(" "),r("a",{attrs:{"data-fancybox":"",title:"向2-结点中插入新键",href:"/pic/algorithm/TjPjNmH.png"}},[r("img",{attrs:{src:"/pic/algorithm/TjPjNmH.png",alt:"向2-结点中插入新键"}})])])]),t._v(" "),r("h4",{attrs:{id:"向3-结点中插入新键"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#向3-结点中插入新键","aria-hidden":"true"}},[t._v("#")]),t._v(" 向3-结点中插入新键")]),t._v(" "),r("blockquote",[r("p",[t._v("假设我们需要向一棵只含有一个3-结点的树中插入一个新键。这棵树有两个键，所以在它唯一的结点中已经没有可插入新建的空间，为了新键的插入，我们先将新键存入该结点中，使之成为一个4-结点，然后将它转换成一棵由3个2-结点组成的2-3树，其中一个结点（根）含有中键，一个结点含有3个键中的最小者（和根结点的左链接相连），一个结点含有3个键中的最大者（和根结点的右链接相连）。这棵树既是一棵含有3个结点的二叉查找树，同时也是一颗完美平衡的2-3树，因为其中所有的空链接到根结点的距离都相等。插入之前树的高度为0，插入后树的高度为1。")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"向3-结点中插入新键",href:"/pic/algorithm/6eCLCN9.png"}},[r("img",{attrs:{src:"/pic/algorithm/6eCLCN9.png",alt:"向3-结点中插入新键"}})])])]),t._v(" "),r("h4",{attrs:{id:"向一个父结点为2-结点的3-结点中插入新键"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#向一个父结点为2-结点的3-结点中插入新键","aria-hidden":"true"}},[t._v("#")]),t._v(" 向一个父结点为2-结点的3-结点中插入新键")]),t._v(" "),r("blockquote",[r("p",[t._v("假设未命中的查找结束于一个3-结点，而他的父结点是一个2-结点。在这种情况下我们需要在"),r("strong",[t._v("维持树的完美平衡的前提下为新键腾出空间")]),t._v("。我们先像刚才那样构造一个4-结点并将其分解，此时的分解不会为中键创建一个新结点，而是将其移动到原来的父结点中。如下")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"向一个父结点为2-结点的3-结点中插入新键",href:"/pic/algorithm/13fbX2B.png"}},[r("img",{attrs:{src:"/pic/algorithm/13fbX2B.png",alt:"向一个父结点为2-结点的3-结点中插入新键"}})])])]),t._v(" "),r("h4",{attrs:{id:"向一个父结点为3-结点的3-结点中插入新键"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#向一个父结点为3-结点的3-结点中插入新键","aria-hidden":"true"}},[t._v("#")]),t._v(" 向一个父结点为3-结点的3-结点中插入新键")]),t._v(" "),r("blockquote",[r("p",[t._v("假设为命中的查找命中于一个父结点为3-结点的结点，我们可以再次像刚才一样构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。但父结点也是一个3-结点，因此我们要用这个中键构造一个新的临时4-结点，然后"),r("strong",[t._v("在这个结点上进行相同的变换")]),t._v("，即分解这个父结点并将它插入到他的父结点中，推广到一般情况，这样一直向上不断分解临时的4-结点并将中键插入到更高级的父结点，直到遇见一个2-结点并将它替换为一个不需要继续分解的3-结点，或者是到达3-结点的根")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"向一个父结点为3-结点的3-结点中插入新键",href:"/pic/algorithm/lgva3EE.png"}},[r("img",{attrs:{src:"/pic/algorithm/lgva3EE.png",alt:"向一个父结点为3-结点的3-结点中插入新键"}})])])]),t._v(" "),r("h4",{attrs:{id:"分解根结点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分解根结点","aria-hidden":"true"}},[t._v("#")]),t._v(" 分解根结点")]),t._v(" "),r("blockquote",[r("p",[t._v("如果从插入结点一直到根结点的路径上都是3-结点，我们的根结点最终变成一个临时的4-结点，我们可以按照向一棵只有3-结点的树中插入新键的方法处理这个问题，将临时的4-结点分解成3个2-结点，使得树高加1."),r("br"),t._v(" "),r("a",{attrs:{"data-fancybox":"",title:"分解根结点",href:"/pic/algorithm/KPWkp4F.png"}},[r("img",{attrs:{src:"/pic/algorithm/KPWkp4F.png",alt:"分解根结点"}})])])]),t._v(" "),r("h2",{attrs:{id:"红黑二叉查找树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#红黑二叉查找树","aria-hidden":"true"}},[t._v("#")]),t._v(" 红黑二叉查找树")]),t._v(" "),r("h3",{attrs:{id:"基本思想："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基本思想：","aria-hidden":"true"}},[t._v("#")]),t._v(" 基本思想：")]),t._v(" "),r("blockquote",[r("p",[t._v("红黑二叉查找树背后的基本思想是用标准的二叉树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。树中的链接分成两种类型："),r("strong",[t._v("红链接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接")]),r("br"),t._v(" "),r("a",{attrs:{"data-fancybox":"",title:"红黑二叉查找树",href:"/pic/algorithm/WQol4hd.png"}},[r("img",{attrs:{src:"/pic/algorithm/WQol4hd.png",alt:"红黑二叉查找树"}})])])]),t._v(" "),r("h3",{attrs:{id:"等价定义："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#等价定义：","aria-hidden":"true"}},[t._v("#")]),t._v(" 等价定义：")]),t._v(" "),r("blockquote",[r("p",[t._v("红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树："),r("br"),t._v("\n1.红链接均为左链接"),r("br"),t._v("\n2.没有任何一个结点同时和两个红链接相连。"),r("br"),t._v("\n3.该输是完美黑色平衡的，即任意空链接到根结点的路径上的"),r("strong",[t._v("黑链接数量")]),t._v("相同。"),r("br"),t._v("\n满足这样定义的红黑树和相应的2-3树是一一对应的")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"2-3树",href:"/pic/algorithm/A6K0FLQ.png"}},[r("img",{attrs:{src:"/pic/algorithm/A6K0FLQ.png",alt:"2-3树"}})])]),t._v(" "),r("p",[t._v("如上图所画的，如果将一棵红黑树中的红链接画平，那么所有的空链接到根结点的距离都是相同的，如果将所有的红链接相连的结点合并，就可以得到一棵2-3树。")])]),t._v(" "),r("h3",{attrs:{id:"实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 实现")]),t._v(" "),r("h4",{attrs:{id:"颜色表示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#颜色表示","aria-hidden":"true"}},[t._v("#")]),t._v(" 颜色表示")]),t._v(" "),r("blockquote",[r("p",[t._v("每一条结点都会只有一条指向自己的链接（从它父结点的父结点指向它），将链接的颜色保存在表示结点的Node数据类型的布尔变量color中。")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"颜色表示",href:"/pic/algorithm/fQmsgdx.png"}},[r("img",{attrs:{src:"/pic/algorithm/fQmsgdx.png",alt:"颜色表示"}})])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("private static final boolean RED = true;\nprivate static final boolean BLACK = false;\n\n//含有color变量的Node对象\nprivate class Node{\n\tKey key;\t\t\t//键\n\tValue value;\t\t//相关联的值\n\tNode left,right;\t//左右子树\n\tint N;\t\t\t\t//这课子树中的节点总数\n\tboolean color;\t\t//由其父节点指向他的链接的颜色\n\t\n\tNode(Key key, Value value, int N, boolean color){\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t\tthis.N = N;\n\t\tthis.color = color;\n\t}\n}\n\nprivate boolean isRed(Node x){\n\tif(x==null)\n\t\treturn false;\n\treturn x.color = RED;\n}\n")])])]),r("h4",{attrs:{id:"旋转"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#旋转","aria-hidden":"true"}},[t._v("#")]),t._v(" 旋转")]),t._v(" "),r("blockquote",[r("p",[t._v("在实现红黑树的操作中可能会出现右链接或者两条连续的红链接，在完成操作之前这些情况都会被小心地旋转并修复。旋转操作会改变红链接的指向，首先假设我们有一条红色的右链接需要被转换成左链接，这种操作叫做左旋转")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"左旋转",href:"/pic/algorithm/AOC0xb3.png"}},[r("img",{attrs:{src:"/pic/algorithm/AOC0xb3.png",alt:"左旋转"}})]),r("br"),t._v("\n同时也有一种操作叫做右旋转，即一条红链接需要被转换成右链接")]),t._v(" "),r("p",[r("a",{attrs:{"data-fancybox":"",title:"右旋转",href:"/pic/algorithm/TYtxeOw.png"}},[r("img",{attrs:{src:"/pic/algorithm/TYtxeOw.png",alt:"右旋转"}})])])]),t._v(" "),r("h5",{attrs:{id:"向单个2-结点插入新键"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#向单个2-结点插入新键","aria-hidden":"true"}},[t._v("#")]),t._v(" 向单个2-结点插入新键")]),t._v(" "),r("blockquote",[r("p",[t._v("一棵只有一个键的红黑树只含有一个2-结点，插入另一个键后，我们需要将他们进行旋转，如果新键小于老键，只需要新增一个红色的结点即可，如果新键大于老键，则需要旋转来进行修改操作，如下图"),r("br"),t._v(" "),r("a",{attrs:{"data-fancybox":"",title:"向单个2-结点插入新键",href:"/pic/algorithm/ECX6yx9.png"}},[r("img",{attrs:{src:"/pic/algorithm/ECX6yx9.png",alt:"向单个2-结点插入新键"}})])])]),t._v(" "),r("h5",{attrs:{id:"向树底部的2-结点插入新键"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#向树底部的2-结点插入新键","aria-hidden":"true"}},[t._v("#")]),t._v(" 向树底部的2-结点插入新键")]),t._v(" "),r("blockquote",[r("p",[t._v("用和二叉查找树相同的方法向一棵红黑树中插入一个新建结点，会在树底部新增一个结点，为了保证有序性，总是用红链接将新结点和它的父结点相连，如果父结点是一个2-结点，那么会出现如图情况\n"),r("a",{attrs:{"data-fancybox":"",title:"向树底部的2-结点插入新键",href:"/pic/algorithm/UY1Fiyl.png"}},[r("img",{attrs:{src:"/pic/algorithm/UY1Fiyl.png",alt:"向树底部的2-结点插入新键"}})])])]),t._v(" "),r("h5",{attrs:{id:"向一棵双键树即一个3-结点插入新键"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#向一棵双键树即一个3-结点插入新键","aria-hidden":"true"}},[t._v("#")]),t._v(" 向一棵双键树即一个3-结点插入新键")]),t._v(" "),r("blockquote",[r("p",[t._v("可以分成三种情况：新键小于树中的两个键，在两者之间，或者是大于树中的两个键，每种情况都会出现一个同时连接到两个红链接的结点。"),r("br"),t._v("\n1.新建大于原树中的两个键"),r("br"),t._v(" "),r("a",{attrs:{"data-fancybox":"",title:"新建大于原树中的两个键",href:"/pic/algorithm/Mqa9W0w.png"}},[r("img",{attrs:{src:"/pic/algorithm/Mqa9W0w.png",alt:"新建大于原树中的两个键"}})]),t._v("\n2.新建小于原树中的两个键\n"),r("a",{attrs:{"data-fancybox":"",title:"新建小于原树中的两个键",href:"/pic/algorithm/GcFfeZ4.png"}},[r("img",{attrs:{src:"/pic/algorithm/GcFfeZ4.png",alt:"新建小于原树中的两个键"}})]),t._v("\n3.新建介于原树中的两个键之间"),r("br"),t._v(" "),r("a",{attrs:{"data-fancybox":"",title:"新建介于原树中的两个键之间",href:"/pic/algorithm/tMjIR69.png"}},[r("img",{attrs:{src:"/pic/algorithm/tMjIR69.png",alt:"新建介于原树中的两个键之间"}})])])]),t._v(" "),r("h5",{attrs:{id:"颜色转换"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#颜色转换","aria-hidden":"true"}},[t._v("#")]),t._v(" 颜色转换")]),t._v(" "),r("blockquote",[r("p",[t._v("除了将子结点的颜色由红变黑之外，还要将父结点的颜色由红变成黑色，这项操作最重要的性质在于"),r("strong",[t._v("它和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性")]),t._v("，我们每次插入后都会将根结点设为黑色（每次根结点由红变黑时树的黑链接高度就会加1），因此：\n1.如果右子结点是红色的而左子结点是黑色的，进行左旋转。"),r("br"),t._v("\n2.如果左子结点是红色的而且它的左子结点也是红色的，进行右旋转。\n3.如果左右子结点均是红色的，进行颜色转换。")])]),t._v(" "),r("h3",{attrs:{id:"算法实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 算法实现")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("/**\n * 红黑树的插入算法\n * @author zzk\n *\n */\npublic class RedBlackBST<Key extends Comparable<Key>,Value> {\n\nprivate static final boolean RED = true;\nprivate static final boolean BLACK = false;\n\nprivate Node root;\n//含有color变量的Node对象\nprivate class Node{\n\tKey key;\t\t\t//键\n\tValue value;\t\t//相关联的值\n\tNode left,right;\t//左右子树\n\tint N;\t\t\t\t//这课子树中的节点总数\n\tboolean color;\t\t//由其父节点指向他的链接的颜色\n\t\n\tNode(Key key, Value value, int N, boolean color){\n\t\tthis.key = key;\n\t\tthis.value = value;\n\t\tthis.N = N;\n\t\tthis.color = color;\n\t}\n}\n\nprivate boolean isRed(Node x){\n\tif(x==null)\n\t\treturn false;\n\treturn x.color = RED;\n}\n\npublic int size(){\n\treturn size(root);\n}\n\nprivate int size(Node x) {\n\tif(x==null)\n\t\treturn 0;\n\telse\n\t\treturn x.N;\n}\n\n//向左旋转h的右链接\nprivate Node rotateLeft(Node h){\n\tNode x = h.right;\n\th.right = x.left;\n\tx.left = h;\n\tx.color = h.color;\n\th.color = RED;\n\tx.N = h.N;\n\th.N = 1 + size(h.left)+ size(h.right);\n\treturn x;\n}\n//向右旋转h的左链接\nprivate Node rotateRight(Node h){\n\tNode x = h.left;\n\th.left = x.right;\n\tx.right = h;\n\tx.color = h.color;\n\th.color = RED;\n\tx.N = h.N;\n\th.N = 1 + size(h.left)+size(h.right);\n\treturn x;\n}\n//颜色转换（转换一个结点的两个红色子结点的颜色）\nprivate void flipColors(Node h){\n\th.color = RED;\n\th.left.color = BLACK;\n\th.right.color = BLACK;\n}\n\npublic void put(Key key, Value value){\n\t//查找key，找到就更新其值，否则就为他新建一个结点\n\troot = put(root, key, value);\n\troot.color = BLACK;\n}\n\n/**\n * 1.如果右子结点是红色的而左结点是黑色的，进行左旋转\n * 2.如果左子结点是红色的且它的左结点也是红色的，进行右旋转\n * 3.如果左右子结点均为红色，进行颜色转换\n * @param h\n * @param key\n * @param value\n * @return\n */\nprivate Node put(Node h, Key key, Value value){\n\tif(h==null)\n\t\treturn new Node(key,value,1,RED);\n\tint cmp = key.compareTo(h.key);\n\tif(cmp<0)\n\t\th.left = put(h.left, key, value);\n\telse if(cmp>0)\n\t\th.right = put(h.right, key, value);\n\telse\n\t\th.value = value;\n\t//如果右子结点是红色的而左结点是黑色的，进行左旋转\n\tif(isRed(h.right) && !isRed(h.left))\n\t\th = rotateLeft(h);\n\t//如果左子结点是红色的且它的左结点也是红色的，进行右旋转\n\tif(isRed(h.left) && isRed(h.left.left))\n\t\th = rotateRight(h);\n\t//如果左右子结点均为红色，进行颜色转换\n\tif(isRed(h.left) && isRed(h.right))\n\t\tflipColors(h);\n\t\n\th.N = size(h.left) + size(h.right) + 1;\n\treturn h;\n}\n\n}\n")])])]),r("h3",{attrs:{id:"红黑树的性质"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#红黑树的性质","aria-hidden":"true"}},[t._v("#")]),t._v(" 红黑树的性质")]),t._v(" "),r("blockquote",[r("p",[t._v("所有基于红黑树的符号实现都能保证操作的运行时间为对数级别（除了范围查找外，他所需的额外时间和返回的键的数量成正比）")])]),t._v(" "),r("blockquote",[r("p",[t._v("各种符号表实现的性能总结：")])]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("算法（数据结构）")]),t._v(" "),r("th",[t._v("最坏的情况下的运行时间的增长数量级（N次插入之后）")]),t._v(" "),r("th",[t._v("-")]),t._v(" "),r("th",[t._v("平均情况下的运行时间的增长数量级（N次随机插入之后）")]),t._v(" "),r("th",[t._v("-")]),t._v(" "),r("th",{staticStyle:{"text-align":"right"}},[t._v("是否支持有序相关的操作")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("-")]),t._v(" "),r("td",[t._v("查找")]),t._v(" "),r("td",[t._v("插入")]),t._v(" "),r("td",[t._v("查找命中")]),t._v(" "),r("td",[t._v("插入")]),t._v(" "),r("td",{staticStyle:{"text-align":"right"}},[t._v("-:")])]),t._v(" "),r("tr",[r("td",[t._v("顺序查询（无序链表）")]),t._v(" "),r("td",[t._v("N")]),t._v(" "),r("td",[t._v("N")]),t._v(" "),r("td",[t._v("N/2")]),t._v(" "),r("td",[t._v("N")]),t._v(" "),r("td",{staticStyle:{"text-align":"right"}},[t._v("否")])]),t._v(" "),r("tr",[r("td",[t._v("二分查找（有序数组）")]),t._v(" "),r("td",[t._v("lgN")]),t._v(" "),r("td",[t._v("N")]),t._v(" "),r("td",[t._v("lgN")]),t._v(" "),r("td",[t._v("N/2")]),t._v(" "),r("td",{staticStyle:{"text-align":"right"}},[t._v("是")])]),t._v(" "),r("tr",[r("td",[t._v("二叉树查找（二叉查找树）")]),t._v(" "),r("td",[t._v("N")]),t._v(" "),r("td",[t._v("N")]),t._v(" "),r("td",[t._v("1.39lgN")]),t._v(" "),r("td",[t._v("1.39lgN")]),t._v(" "),r("td",{staticStyle:{"text-align":"right"}},[t._v("是")])]),t._v(" "),r("tr",[r("td",[t._v("2-3树查找")]),t._v(" "),r("td",[t._v("2lgN")]),t._v(" "),r("td",[t._v("2lgN")]),t._v(" "),r("td",[t._v("1.00lgN")]),t._v(" "),r("td",[t._v("1.00lgN")]),t._v(" "),r("td",{staticStyle:{"text-align":"right"}},[t._v("是")])])])])])},[],!1,null,null,null);a.default=n.exports}}]);