(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{823:function(t,a,s){"use strict";s.r(a);var n=s(115),e=Object(n.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述","aria-hidden":"true"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("blockquote",[s("p",[t._v("Java 1.5版本中增加泛型（Generice）。在没有泛型之前，从集合中读取到的每一个对象都必须进行转换，如果不小心插入了类型错误的对象，在运行时的转换处理就会出错。有了泛型之后，可以告诉编译器每个集合中接受哪些对象类型。编译器自动地为你的插入进行转化，并在编译时告知是否插入了类型错误的对象。这样可以使程序既更加安全")])]),t._v(" "),s("h2",{attrs:{id:"第二十三条：请不要在新代码中使用原生态类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二十三条：请不要在新代码中使用原生态类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 第二十三条：请不要在新代码中使用原生态类型")]),t._v(" "),s("p",[t._v("声明中具有一个或者多个类型参数（type parameter）的类或者接口，就是泛型（generic）；类或接口。从Java 1.5发行版本起，List接口就只有单个类型参数E，表示列表的元素类型。")]),t._v(" "),s("p",[t._v("每种泛型定义一组参数化的类型（parameterized type），构成格式为：先是类或者接口的名称，接着用尖括号(<>)把对应于泛型形式类型参数的实际类型参数列表括起来。例如，List<String> 是一个参数化的类型，表示元素类型为String的列表")]),t._v(" "),s("p",[t._v("最后一点，每个泛型都定义一个原生态类型（raw type），即不带任何实际类型参数的泛型名称，例如，与List<E>相对应的原生态类型是List。"),s("strong",[t._v("原生态类型就像是从类型声明中删除了所有泛型信息一样")]),t._v("。实际上，原生态类型List与java平台没有泛型之前额接口类型List完全一样")]),t._v(" "),s("p",[t._v("如：")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("private final Collection stamps "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstamps.add"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("new Coin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),t._v("."),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("))")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("像上面如果不小心将一个coin放进stamps集合中，这一错误的插入照样得以编译和运行并且不会出现任何错误提，只会到从stamps集合中获取coin时才会收到错误提示,如下")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("for"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Iterator i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" stamps.iterator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i.hasNext"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    stamp s "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Stamp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" i.next"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" //报错\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("这种错误应该在编译时就发现，有了泛型就可以利用改进后的类型声明，编译器就知道stamps应该只包含Stamp实例，如下，错误的插入就产生一条编译时的错误")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("private final Collection"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Stamp"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" stamps "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("..")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v("总之，使用原生态类型会在运行时导致异常，因此不要在新代码中使用。原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的，Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合；Set<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合；Set则是个原生态类型，它脱离了泛型系统，前面两种是安全的，最后一种不安全")])]),t._v(" "),s("h2",{attrs:{id:"第二十四条：消除非受检警告"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二十四条：消除非受检警告","aria-hidden":"true"}},[t._v("#")]),t._v(" 第二十四条：消除非受检警告")]),t._v(" "),s("blockquote",[s("p",[t._v('用泛型编程时，会遇到许多编译器警告：非受检强制转化警告（unchecked cast warnings）、非受检方法调用警告、非受检普通数组创建警告，以及非受检转换警告（unchecked conversion warnings），这些警告很重要，不要忽略他们，每一条警告都表示可能在运行时抛出ClassCastException异常。要尽最大努力消除这些警告。如果无法消除非受检警告，同时可以证明引起警告的代码是类型安全的，就尽可能小的范围内，用@SupperessWarnings("unchecked")注释禁止该警告，要用注释把警告原因记录下来')])]),t._v(" "),s("h2",{attrs:{id:"第二十五条：列表优先于数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二十五条：列表优先于数组","aria-hidden":"true"}},[t._v("#")]),t._v(" 第二十五条：列表优先于数组")]),t._v(" "),s("h3",{attrs:{id:"数组和泛型相比，有两个重要的不同点："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组和泛型相比，有两个重要的不同点：","aria-hidden":"true"}},[t._v("#")]),t._v(" 数组和泛型相比，有两个重要的不同点：")]),t._v(" "),s("ul",[s("li",[t._v("数组是协变的（covariant）如果Sub为Super的子类型，那么数组类型Sub[]就是Super[]的子类型。相反，泛型则是不可变的（invariant）：对于任意两个不同的类型Type1和Type2，List<Type1>既不是List<Type2>的子类型，也不是List<Type2>的超类型")])]),t._v(" "),s("p",[t._v("下面的代码片段是合法的")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("//运行时会失败\nObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" objectArray "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new Long"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nObjectArray"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"I don\'t fit in"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("但下面的代码片段是不合法的")]),t._v(" "),s("div",{staticClass:"language-bash extra-class"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[t._v("//编译时会失败\nList"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Object"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" ol "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" new ArrayList"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Long"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nol.add"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"I don\'t fit in"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("blockquote",[s("p",[t._v("无论哪种方法，都不能将String放入Long容器中，利用数组，在运行时发现所犯的错误；利用列表则可以在编译时发现错误")])]),t._v(" "),s("ul",[s("li",[t._v("数组是具体化的（reified），因此数组会在运行时才知道并检查他们的元素类型约束，如上面的代码，会得到一个ArrayStoreException异常。相比下，泛型则是通过擦除（erasure）来实现的，因此泛型只在编译时强化他们的类型信息，在运行时丢弃（或擦除）他们的元素类型信息。擦除是使泛型可以与没有使用泛型的代码随意进行互用 ，上面第二段代码之所以不合法就是因为编译器无法在运行时检查转换的安全性，元素类型信息会在运行时从泛型中被擦除")])]),t._v(" "),s("h2",{attrs:{id:"第二十六条：优先考虑泛型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二十六条：优先考虑泛型","aria-hidden":"true"}},[t._v("#")]),t._v(" 第二十六条：优先考虑泛型")]),t._v(" "),s("h2",{attrs:{id:"第二十七条：优先考虑泛型方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二十七条：优先考虑泛型方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 第二十七条：优先考虑泛型方法")]),t._v(" "),s("h2",{attrs:{id:"第二十八条：利用有限制通配符来提升api的灵活性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二十八条：利用有限制通配符来提升api的灵活性","aria-hidden":"true"}},[t._v("#")]),t._v(" 第二十八条：利用有限制通配符来提升API的灵活性")]),t._v(" "),s("h2",{attrs:{id:"第二十九条：优先考虑类型安全的异构容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第二十九条：优先考虑类型安全的异构容器","aria-hidden":"true"}},[t._v("#")]),t._v(" 第二十九条：优先考虑类型安全的异构容器")])])},[],!1,null,null,null);a.default=e.exports}}]);