(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{811:function(t,v,_){"use strict";_.r(v);var e=_(115),d=Object(e.a)({},function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"符号表的内存使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#符号表的内存使用","aria-hidden":"true"}},[t._v("#")]),t._v(" 符号表的内存使用")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("方法")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("N个元素所需的内存（引用类型）")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("基于拉链法的散列表")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("~48N + 32M")])]),t._v(" "),_("tr",[_("td",[t._v("基于线性探测的散列表")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("？ \t在~32N 和 ~128N之间")])]),t._v(" "),_("tr",[_("td",[t._v("各种二叉查找树")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("~56N")])])])]),t._v(" "),_("blockquote",[_("p",[t._v("拉链法和线性探测法的详细比较取决于实现的细节和用例对空间和时间要求，即使基于性能考虑，选择拉链法而非线性探测法也不一定是合理的，在实践中，两种方法的性能差别主要是因为拉链法为每一个键都分配了一小块内存而线性探测则为了整个表使用了两个很大的数组")])]),t._v(" "),_("p",[t._v("对于散列表来说，并非是包治百病的灵丹妙药，因为")]),t._v(" "),_("ol",[_("li",[t._v("每种类型的键都需要一个优秀的散列函数。")]),t._v(" "),_("li",[t._v("性能保证保证来自散列函数的质量")]),t._v(" "),_("li",[t._v("散列函数的计算可能复杂而昂贵")]),t._v(" "),_("li",[t._v("难以支撑有序性相关的符号表操作")])]),t._v(" "),_("h2",{attrs:{id:"符号表的比较"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#符号表的比较","aria-hidden":"true"}},[t._v("#")]),t._v(" 符号表的比较")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("算法（数据结构）")]),t._v(" "),_("th",[t._v("最坏情况下的运行时间的增长数量级（N次插入之后）")]),t._v(" "),_("th",[t._v("-")]),t._v(" "),_("th",[t._v("平均情况下的运行时间的增长数量级（N次随机插入之后）")]),t._v(" "),_("th",[t._v("-")]),t._v(" "),_("th",[t._v("关键接口")]),t._v(" "),_("th",{staticStyle:{"text-align":"left"}},[t._v("内存使用")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("-")]),t._v(" "),_("td",[t._v("查找")]),t._v(" "),_("td",[t._v("插入")]),t._v(" "),_("td",[t._v("查找命中")]),t._v(" "),_("td",[t._v("插入")]),t._v(" "),_("td",[t._v("-")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("-")])]),t._v(" "),_("tr",[_("td",[t._v("顺序查询（无序链表）")]),t._v(" "),_("td",[t._v("N")]),t._v(" "),_("td",[t._v("N")]),t._v(" "),_("td",[t._v("N/2")]),t._v(" "),_("td",[t._v("N")]),t._v(" "),_("td",[t._v("equals()")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("48N")])]),t._v(" "),_("tr",[_("td",[t._v("二分查找（有序数组）")]),t._v(" "),_("td",[t._v("lgN")]),t._v(" "),_("td",[t._v("N")]),t._v(" "),_("td",[t._v("lgN")]),t._v(" "),_("td",[t._v("N/2")]),t._v(" "),_("td",[t._v("compareTo()")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("16N")])]),t._v(" "),_("tr",[_("td",[t._v("二叉树查找（二叉查找树）")]),t._v(" "),_("td",[t._v("N")]),t._v(" "),_("td",[t._v("N")]),t._v(" "),_("td",[t._v("1.39lgN")]),t._v(" "),_("td",[t._v("1.39lgN")]),t._v(" "),_("td",[t._v("compareTo()")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("64N")])]),t._v(" "),_("tr",[_("td",[t._v("2-3树查找树（红黑树）")]),t._v(" "),_("td",[t._v("2lgN")]),t._v(" "),_("td",[t._v("2lgN")]),t._v(" "),_("td",[t._v("1.00lgN")]),t._v(" "),_("td",[t._v("N/2")]),t._v(" "),_("td",[t._v("compareTo()")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("64N")])]),t._v(" "),_("tr",[_("td",[t._v("拉链法（链表数组）")]),t._v(" "),_("td",[t._v("<lgN")]),t._v(" "),_("td",[t._v("<lgN")]),t._v(" "),_("td",[t._v("N/(2M)")]),t._v(" "),_("td",[t._v("N/M")]),t._v(" "),_("td",[t._v("equals();hashCode()")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("48N + 32N")])]),t._v(" "),_("tr",[_("td",[t._v("线性探测法（并行数组）")]),t._v(" "),_("td",[t._v("clogN")]),t._v(" "),_("td",[t._v("clgN")]),t._v(" "),_("td",[t._v("<1.5")]),t._v(" "),_("td",[t._v("<2.5")]),t._v(" "),_("td",[t._v("equals();hashCode()")]),t._v(" "),_("td",{staticStyle:{"text-align":"left"}},[t._v("在32N和128N之间")])])])]),t._v(" "),_("p",[t._v("如表可以知道，对于典型的应用程序，应该在散列表和二叉树之间进行选择。")]),t._v(" "),_("p",[_("strong",[t._v("相对于二叉查找树，散列表的优点")]),t._v("在于代码更加简单，且查找时间最优（常数级别，只要键的数据类型是标准的或者简单到我们可以为他写出满足（或者近似满足）均匀性假设的高效散列函数即可）。")]),t._v(" "),_("p",[_("strong",[t._v("二叉查找树相对于散列表的优点在于")]),t._v("抽象结构更简单（不需要设计散列函数），红黑树可以保证最坏情况下的性能且它能够支持的操作更多（如排位，选择，排序和范围查找）。")])])},[],!1,null,null,null);v.default=d.exports}}]);