(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{829:function(a,e,r){"use strict";r.r(e);var t=r(115),i=Object(t.a)({},function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h2",{attrs:{id:"概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#概述","aria-hidden":"true"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),r("blockquote",[r("p",[a._v("本章关注对象序列化（Object serialization）API，它提供了一个框架，用来将对象编码成字节流，并从字节流编码中重新构建对象。“将一个对象编码成一个字节流”，称作该对象序列化（serializing）；相反的处理过程被称作反序列化（deserializing）。一旦对象被序列化后，它的编码就可以从一台正在运行的虚拟机被传递到另一台虚拟机上，或者被存储到磁盘上，供以后反序列化时使用。序列化技术为远程通信提供了标准的线路级（wire-level）对象表示法，也为javaBeans组件结构提供了标准的持久化数据格式。")])]),a._v(" "),r("h2",{attrs:{id:"第七十四条：谨慎地实现serializable接口"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第七十四条：谨慎地实现serializable接口","aria-hidden":"true"}},[a._v("#")]),a._v(" 第七十四条：谨慎地实现Serializable接口")]),a._v(" "),r("ul",[r("li",[r("p",[r("strong",[a._v("实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性")]),a._v("。如果一个类实现了Serializable接口，它的字节流编码（或者说序列化形式，serialized form）就变成它的导出的API的一部分。一旦这个类被广泛使用，往往必须永远支持这种序列化形式，如果不设计一种自定义的序列化形式，而仅仅接受了默认的序列化形式，这种序列化形式将被永远的束缚在该类最初的内部表达式上。换句话说，如果接受了默认的序列化形式，这个类中私有的和包级私有的实例域将都变成导出的API的一部分，不符合最低限度的访问域的实践准则，从而失去了作为信息隐藏工具的有效性")])]),a._v(" "),r("li",[r("p",[r("strong",[a._v("实现Serializable的第二个代价是，它增加了出现Bug和安全漏洞的可能性")]),a._v("。通常情况下，对象是利用构造器来创建的；序列化机制是一种语言之外的对象创建机制（extralinguisticmechanism）。无论是接受了默认的行为，还是覆盖了默认的行为，反序列化机制都是一个“隐藏的构造器”，具备与其他构造器相同的特点。因为反序列化机制中没有显式的构造器，所以要确保：反序列化过程必须也要保证所有“由真正的构造器建立起来的约束关系”，并且不允许攻击者访问正在构造中的对象的内部信息。依靠默认的反序列化机制，很容易使对象的约束关系遭到破坏，以及遭受到非法访问")])]),a._v(" "),r("li",[r("p",[r("strong",[a._v("实现Serializable的第三个代价是，随着类发行新的版本，相关的测试负担也增加了。")])])])]),a._v(" "),r("blockquote",[r("p",[a._v("实现Serializable接口提供了一些实在的益处：如果一个类将要加入到某个框架中，并且该框架依赖于序列化来实现对象传输或持久化，对于这个类来讲，实现Serializable接口就非常有必要，更进一步来说，如果这个类要成为另一个类的组件，并且后者必须实现Serializable接口，若前者也实现了Serializable接口，他就会更易于被后者使用。")])]),a._v(" "),r("h2",{attrs:{id:"第七十五条：考虑使用自定义的序列化形式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第七十五条：考虑使用自定义的序列化形式","aria-hidden":"true"}},[a._v("#")]),a._v(" 第七十五条：考虑使用自定义的序列化形式")]),a._v(" "),r("blockquote",[r("p",[a._v("当决定要将一个类做成可序列化的时候，请仔细考虑应该采用什么样的序列化形式，只有当默认的序列化形式能够合理地描述对象的逻辑状态时，才能使用默认的序列化形式；否则就要设计一个自定义的序列化形式，通过它合理的描述对象的状态。你应该分配足够多的时间来设计类的序列化形式，就好像分配足够多的时间来设计它的导出方法一样。正如无法在将来的版本去掉导出方法一样，你也不能去掉序列化形式中的域；它们必须被永久地保留下去，以确保序列化兼容性（serialization compalibility）。选择错误的序列化形式对于一个类的复杂性和性能会有永久的负面影响")])]),a._v(" "),r("h2",{attrs:{id:"第七十六条：保护性地编写readobject方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第七十六条：保护性地编写readobject方法","aria-hidden":"true"}},[a._v("#")]),a._v(" 第七十六条：保护性地编写readObject方法")]),a._v(" "),r("h3",{attrs:{id:"有助于编写出更加健壮的readobject方法的指导方法："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有助于编写出更加健壮的readobject方法的指导方法：","aria-hidden":"true"}},[a._v("#")]),a._v(" 有助于编写出更加健壮的readObject方法的指导方法：")]),a._v(" "),r("ul",[r("li",[a._v("对于对象引用域必须保持为私有的类，要保护性地拷贝这些域中的每个对象，不可变类的可变组件就属于这一类别")]),a._v(" "),r("li",[a._v("对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后")]),a._v(" "),r("li",[a._v("如果整个对象图在被反序列化之后必须进行验证，就应该使用ObjectInputValidation接口")]),a._v(" "),r("li",[a._v("无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法")])]),a._v(" "),r("h2",{attrs:{id:"第七十七条：对于实例控制，枚举类型优先于readresolve"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第七十七条：对于实例控制，枚举类型优先于readresolve","aria-hidden":"true"}},[a._v("#")]),a._v(" 第七十七条：对于实例控制，枚举类型优先于readResolve")]),a._v(" "),r("h2",{attrs:{id:"第七十八条：考虑用序列化代理代替序列化实例"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第七十八条：考虑用序列化代理代替序列化实例","aria-hidden":"true"}},[a._v("#")]),a._v(" 第七十八条：考虑用序列化代理代替序列化实例")])])},[],!1,null,null,null);e.default=i.exports}}]);