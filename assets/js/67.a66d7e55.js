(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{860:function(a,t,e){"use strict";e.r(t);var v=e(115),i=Object(v.a)({},function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h2",{attrs:{id:"前言"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),e("p",[a._v("在学习volatile之前先了解"),e("strong",[a._v("CPU Cache")]),a._v("，"),e("strong",[a._v("Java内存模型")]),a._v("以及"),e("strong",[a._v("并发编程")]),a._v("的三种特性相关知识")]),a._v(" "),e("h2",{attrs:{id:"cpu-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cpu-cache","aria-hidden":"true"}},[a._v("#")]),a._v(" CPU Cache")]),a._v(" "),e("p",[a._v("在计算机中，所有的运算操作都是由CPU的寄存器来完成的，CPU指令的执行过程需要涉及数据的读取和写入，CPU所能访问的所有数据只能是计算机的主存（通常是指RAM），虽然CPU的发展频率不断得到提升，但受限于制造工艺以及成本等的限制，计算机的内存反倒在访问速度上并没有多大的突破，因此CPU的处理速度和内存的访问速度之间的差距越来越大。")]),a._v(" "),e("p",[a._v("由于两边速度严重不对等，所以就有了CPU和主存之间增加缓存Cache的设计，Cache的出现是为了解决CPU直接访问内存效率低下问题，在程序运行的过程中，会将运算所需的数据从主存复制一份到CPU Cache中，这样CPU进行计算时就可以直接对CPU Cache中的数据进行读取和写入，当运算结束之后，再将CPU Cache中的最新数据刷新到主内存当中，CPU通过直接访问Cache的方式替代直接访问主内存的方法极大地提高了CPU地吞吐能力。")]),a._v(" "),e("p",[a._v("由于缓存的出现，极大提高了CPU的吞吐能力，但是同时也引入了缓存不一致的问题，比如 i++ 这个操作，在程序运行过程中，首先将主内存中的数据复制一份存放到CPU Cache中，那么CPU 寄存器在进行数值计算的时候就直接到Cache中读取和写入，当整个过程运算结束之后再将Cache中的数据刷新到主存当中，具体过程如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("  1. 读取主内存的 i 到CPU Cache中\n\n  2. 对i进行加一操作\n\n  3. 将结果写回到CPU Cache中\n\n  4. 将数据刷新到主内存中\n")])])]),e("p",[a._v("i++ 在单线程的情况下不会出现任何问题，但是在多线程的情况下就会有问题，每个线程都有自己的工作内存（本地内存，对应于CPU中的Cache），变量 i 会在多个线程的本地内存中存一个副本。如果同时有两个线程执行 i++ 操作，假设 i 的初始值为0， 每一个线程都从主内存中获取i的值存入 CPU Cache中，然后经过计算再写入主内存中，很多可能 i 在经过两次自增之后结果还是1，这就是典型的"),e("strong",[a._v("缓存不一致性问题")])]),a._v(" "),e("h2",{attrs:{id:"java内存模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java内存模型","aria-hidden":"true"}},[a._v("#")]),a._v(" Java内存模型")]),a._v(" "),e("p",[e("strong",[a._v("Java的内存模型(Java Memory Mode, JMM)")]),a._v(" 指定了Java虚拟机如何与计算的主存(RAM)进行工作，决定了一个线程对共享变量的写入何时对其他线程可见，还定义了线程与主内存之间的抽象关系，如下：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v(" 1. 共享变量存储于主内存中，每个线程都可以访问\n\n 2. 每个线程都有私有的工作内存或者本地内存\n\n 3. 工作内存只存储该线程对共享变量的副本\n")])])]),e("h2",{attrs:{id:"并发编程的三种特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发编程的三种特性","aria-hidden":"true"}},[a._v("#")]),a._v(" 并发编程的三种特性")]),a._v(" "),e("p",[a._v("并发编程有三个至关重要的特性，分别是"),e("strong",[a._v("原子性")]),a._v("，"),e("strong",[a._v("可见性")]),a._v("和"),e("strong",[a._v("有序性")])]),a._v(" "),e("ol",[e("li",[e("p",[e("strong",[a._v("原子性")]),a._v("：是指在一次的操作或者多次操作中，要么所有的操作全部得到执行并且不受到任何因素的干扰而中断，要么所有的操作都不执行")])]),a._v(" "),e("li",[e("p",[e("strong",[a._v("可见性")]),a._v("：是指当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值")])]),a._v(" "),e("li",[e("p",[e("strong",[a._v("有序性")]),a._v("：是指程序代码在执行过程中的先后顺序，由于Java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序，比如")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v(" int x = 10;\n int y = 0;\n x++;\n y = 20;\n")])])])])]),a._v(" "),e("p",[a._v("从编程的角度来看，上面的代码肯定顺序执行下来的，但是在JVM真正地运行这段代码却未必是这样的顺序，比如 y = 20 语句可能会在x++语句前面得到执行，这种情况就是"),e("strong",[a._v("指令重排序（Instruction Recorder）")])]),a._v(" "),e("p",[a._v("一般来说，处理器为了提高程序的运行效率，可能会对输入的代码指令做一定的优化，它不会百分之百的保证代码的执行顺序严格按照编写代码中的顺序来进行，但它会保证程序的最终运行结果是编码时所期望的结果。")]),a._v(" "),e("p",[a._v("在单线程情况下，无论怎样的重排序最终都会保证程序的执行结果和代码顺序的结果完全是一致的，但是在多线程的情况下，如果有序性得不到保证，那么很有可能会出现非常大的问题，如下")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("\t private  boolean initialized = false;\n\t private  Context context;\n\t public  Context load(){\n\t\t\n\t\tif(!initialized){\n\t\t\tcontext = loadContext();\n\t\t\tinitialized = true;\n\t\t}\t\n\t\t\t\n\t }\n")])])]),e("p",[a._v("上述代码使用boolean变量initialized来控制context是否已经被记载，在单线程下无论怎样的重排序，最终返回给使用者的context都是可用的。")]),a._v(" "),e("p",[a._v("如果在多线程的情况下发生了重排序，比如context=loadContext()的执行被重排序到了initialized = true的后面，那么会出现错误")]),a._v(" "),e("p",[a._v("比如第一个线程首先判断到了initialized = false，因此准备执行loadContext操作，但是由于重排序，先将initialized设值为true然后执行loadContext()方法，那么如果另外一个线程也执行load()方法，发现initialized为true，直接返回一个加载未成功的context，那么就会出现错误")]),a._v(" "),e("h3",{attrs:{id:"jmm如何保证三大特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jmm如何保证三大特性","aria-hidden":"true"}},[a._v("#")]),a._v(" JMM如何保证三大特性")]),a._v(" "),e("p",[a._v("JVM采用"),e("strong",[a._v("内存模型的机制")]),a._v("屏蔽各个平台和操作系统之间内存访问的差异，以实现让java程序在各个平台下达到一致的内存访问效果。")]),a._v(" "),e("p",[a._v("Java的内存模型规定了所有的变量都是存在于主内存（RAM）当中的，而每个线程都有自己的工作内存或者本地内存，线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接对主内存进行操作，并且每一个线程都不能访问其他线程的工作内存或者本地内存")]),a._v(" "),e("h3",{attrs:{id:"jmm与原子性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jmm与原子性","aria-hidden":"true"}},[a._v("#")]),a._v(" JMM与原子性")]),a._v(" "),e("p",[a._v("在Java语言中，对基本数据类型的变量操作都是原子性的，对引用类型的变量读取和赋值的操作也是原子性的，因此诸如此类的操作是不可中断的，要么执行，要么不执行")]),a._v(" "),e("h4",{attrs:{id:"例子："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#例子：","aria-hidden":"true"}},[a._v("#")]),a._v(" 例子：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("x = 10； 赋值操作\n")])])]),e("blockquote",[e("p",[a._v("x = 10的操作是原子性的，执行线程首先会将x = 10 写入工作内存中，然后再将其写入主内存")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("y = x; 赋值操作\n")])])]),e("blockquote",[e("p",[a._v("该操作是非原子性的，因为它包含了两个重要步骤")]),a._v(" "),e("blockquote",[e("ul",[e("li",[a._v("a. 执行线程从主内存中读取x的值(如果x已经存在于执行线程的工作内存中，则直接获取)然后将其存入当前线程的工作内存中")]),a._v(" "),e("li",[a._v("b. 在执行线程的工作内存中，修改y的值为x，然后将y的值写入主内存中")])])]),a._v(" "),e("p",[a._v("虽然第一步和第二步都是原子类型的操作，但是合在一起就不是原子操作")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("y++；自增操作\n")])])]),e("blockquote",[e("p",[a._v("该操作是非原子性的，因为它包含了三个重要的操作")]),a._v(" "),e("blockquote",[e("ul",[e("li",[a._v("a. 执行线程从主内存中读取y的值(如果y已经存在于执行线程的工作内存中，则直接获取)然后将其存入当前线程的工作内存中")]),a._v(" "),e("li",[a._v("b. 在执行线程工作内存中为y执行加1操作")]),a._v(" "),e("li",[a._v("c. 将y的值写入主内存")])])])]),a._v(" "),e("h5",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),e("p",[a._v("结合上述例子，可以发现只有第一种操作即赋值操作具备原子性，其余都不具备原子性，可以得出")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("多个原子性的操作在一起不再是原子性操作")])]),a._v(" "),e("li",[e("p",[a._v("简单的读取与赋值操作是原子性，将一个变量赋给另外一个变量的操作不是原子性的")])]),a._v(" "),e("li",[e("p",[a._v("Java内存模型（JMM）只保证了基本读取和赋值的原子性操作，其他的均不保证，如果想要使得某些代码片段具备原子性，需要使用关键字synchronized，或者JUC中的lock。如果想要使得int等类型自增操作具备原子性，可以使用JUC包下的原子封装类型java.util.concurrent.atomic.*.")])])]),a._v(" "),e("h3",{attrs:{id:"jmm与可见性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jmm与可见性","aria-hidden":"true"}},[a._v("#")]),a._v(" JMM与可见性")]),a._v(" "),e("p",[a._v("在多线程的环境下，如果某个线程首次读取共享变量，则首先要到主内存中获取该变量，然后存入工作内存中，以后只需要在工作内存中读取该变量即可。同样如果对该变量执行了修改的操作，则先将新值写入工作内存中，然后再刷新至主内存中，但是什么时候最新的值会被刷新到主内存中是不确定的，这时候就会出现缓存不一致的问题")]),a._v(" "),e("h4",{attrs:{id:"java-提供了以下三种方式来保证可见性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java-提供了以下三种方式来保证可见性","aria-hidden":"true"}},[a._v("#")]),a._v(" java 提供了以下三种方式来保证可见性")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("使用关键字volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接再主内存中进行（当然也会缓存到工作内存中，当其他线程对该共享资源进行了修改，则会导致当前线程在工作内存中的共享资源失效，所以必须从主内存中再次获取），对于共享资源的写操作先修改工作内存，但是修改结束后会立刻将其刷新到主内存中。")])]),a._v(" "),e("li",[e("p",[a._v("通过synchronized关键字能够保证可见性，synchronized关键字能够保证同一时刻只有一个线程获得锁，然后执行同步方法，并且还会确保在锁释放之前，会将对变量的修改刷新到主内存当中。")])]),a._v(" "),e("li",[e("p",[a._v("通过JUC提供的显示锁Lock也能保证可见性，Lock的lock方法能够保证在同一时刻只有一个线程获得锁然后执行同步方法，并且会确保在锁释放(Lock的unlock方法)之前会将变量的修改刷新到主内存中")])])]),a._v(" "),e("h3",{attrs:{id:"jmm与有序性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jmm与有序性","aria-hidden":"true"}},[a._v("#")]),a._v(" JMM与有序性")]),a._v(" "),e("p",[a._v("在Java内存模型中，允许编译器和处理器对指令进行重排序，在单线程的情况下，重排序并不会引起什么，但是在多线程的情况下，重排序会影响程序的正常运行")]),a._v(" "),e("h4",{attrs:{id:"java提供了三种保证有序性的方式，具体如下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#java提供了三种保证有序性的方式，具体如下","aria-hidden":"true"}},[a._v("#")]),a._v(" java提供了三种保证有序性的方式，具体如下")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("1. 使用volatile关键字保证有序性\n\n2. 使用synchronized关键字保证有序性\n\n3. 使用显式锁Lock来保证有序性\n")])])]),e("h4",{attrs:{id:"happens-before原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#happens-before原则","aria-hidden":"true"}},[a._v("#")]),a._v(" Happens-before原则")]),a._v(" "),e("p",[a._v("Java的内存模型有一些天生的有序性规则，不需要任何同步手段就能保证有序性，这个规则被称为"),e("strong",[a._v("Happens-before原则")]),a._v("，具体如下")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("1.程序次序规则：在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生于编写在前面的操作之后。\n")])])]),e("blockquote",[e("p",[a._v("这句话的意思看起来是程序按照编写的顺序来执行，但是虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终结果和代码执行的结果一致即可。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("2.锁定规则：一个unlock操作要先行发生于对同一个锁的lock操作\n")])])]),e("blockquote",[e("p",[a._v("这句话的意思是，无论是在单线程还是在多线程的环境下，如果同一个锁是锁定状态，那么必须先对其执行释放操作之后才能继续进行lock操作。")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("3.volatile变量规则：对一个变量的写操作要早于对这个变量之后的读操作\n")])])]),e("blockquote",[e("p",[a._v("按照字面上的意思来说就是，如果一个变量使用volatile关键字修饰，一个线程对它进行都操作，一个线程对它进行写操作，那么写入操作肯定要先于读操作")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("4.传递规则：如果操作A先于操作B，而操作B又先于操作C，则可以得出操作A肯定要先于操作C\n")])])]),e("blockquote",[e("p",[a._v("这一点说明了happens-before原则具备传递性")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("5.程序启动规则：Thread对象的start()方法先行发生于对该线程的任何动作\n")])])]),e("blockquote",[e("p",[a._v("这也就是只有start之后线程才能真正运行，否则Thread只是一个对象而已")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("6.线程中断规则：对线程执行interrupt()方法肯定要优先于捕获到中断信号\n")])])]),e("blockquote",[e("p",[a._v("这句话的意思是如果线程收到中断信息，那么之前势必要有interrupt().")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("7. 线程的终结规则：线程中所有的操作都要先行发生于线程的终止检测\n")])])]),e("blockquote",[e("p",[a._v("通俗的讲，线程的任务执行，逻辑单元执行肯定是要发生于线程死亡之前")])]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[a._v("8. 对象的终结规则：一个对象初始化的完成先行发生于finalize()方法之前\n")])])]),e("h2",{attrs:{id:"volatile学习"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile学习","aria-hidden":"true"}},[a._v("#")]),a._v(" volatile学习")]),a._v(" "),e("h3",{attrs:{id:"volatile关键字语义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volatile关键字语义","aria-hidden":"true"}},[a._v("#")]),a._v(" volatile关键字语义")]),a._v(" "),e("p",[a._v("被volatile修饰的实例变量或者类变量具备如下两层语义")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("保证了不同线程之间对变量操作时的可见性，也就是说当一个线程修改volatile修改的变量，另外一个线程会立即看到最新的值（"),e("strong",[a._v("保证可见性")]),a._v("）")])]),a._v(" "),e("li",[e("p",[a._v("禁止对指令进行重排序操作（"),e("strong",[a._v("保证顺序性")]),a._v("）")])])]),a._v(" "),e("blockquote",[e("p",[a._v("注：volatile 不具备保证原子性的语义")])]),a._v(" "),e("h3",{attrs:{id:"volation和synchronized"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#volation和synchronized","aria-hidden":"true"}},[a._v("#")]),a._v(" volation和synchronized")]),a._v(" "),e("p",[e("strong",[a._v("1. 使用上的区别")])]),a._v(" "),e("blockquote",[e("ul",[e("li",[a._v("volatile关键字只能用于修饰实例变量或者类变量，不能用于修饰方法以及方法参数和局部变量，常量等")]),a._v(" "),e("li",[a._v("synchronized关键字不能用于对变量的修饰，只能用于修饰方法或者语句块")]),a._v(" "),e("li",[a._v("volatile修饰的变量可以为null，synchronized关键字同步语句块的monitor对象不能为null")])])]),a._v(" "),e("p",[e("strong",[a._v("2. 对原子性的保证")])]),a._v(" "),e("blockquote",[e("ul",[e("li",[a._v("volatile无法保证原子性")]),a._v(" "),e("li",[a._v("由于synchronized是一种排他的机制，因此被synchronized关键字修饰的同步代码是无法被打断的，因此可以保证代码的原子性")])])]),a._v(" "),e("p",[e("strong",[a._v("3. 可见性的保证")])]),a._v(" "),e("blockquote",[e("ul",[e("li",[a._v("两者均可保证共享资源在多线程间的可见性，但是实现机制完全不一样")]),a._v(" "),e("li",[a._v("synchronized借助JVM指令monitor enter 和monitor exit对通过排他的方式使得同步代码串行化，在monitor exit时所有共享资源都会被刷新到主内存中")]),a._v(" "),e("li",[a._v("相比较于synchronized关键字volatile使用机器指令（偏硬件）“lock；”的方式迫使其他线程工作内存中的数据失效，不得到主内存中进行再次加载")])])]),a._v(" "),e("p",[e("strong",[a._v("4. 对有序性的保证")])]),a._v(" "),e("blockquote",[e("ul",[e("li",[a._v("volatile关键字禁止JVM编译器以及处理器对其进行重排序，所以他能够保证有序性")]),a._v(" "),e("li",[a._v("虽然synchronized关键字所修饰的同步方法也可以保证顺序性，但是这种顺序性是以程序串行化执行换来的，即synchronized修饰的代码块中代码指令也是会发生指令重排序的，但是最终输出结果和代码编写顺序的结果是一致的")])])]),a._v(" "),e("p",[e("strong",[a._v("5. 其他")])]),a._v(" "),e("blockquote",[e("ul",[e("li",[a._v("volatile不会使得线程陷入堵塞\n-synchronized 关键字会使线程进入阻塞状态")])])])])},[],!1,null,null,null);t.default=i.exports}}]);