<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>创建和销毁对象 | Koala &#39;s blog</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    <meta name="description" content="欢迎来到我的博客">
    <link rel="preload" href="/assets/css/0.styles.0dca6718.css" as="style"><link rel="preload" href="/assets/js/app.193c9b61.js" as="script"><link rel="preload" href="/assets/js/2.be286493.js" as="script"><link rel="preload" href="/assets/js/48.bdbc5c65.js" as="script"><link rel="prefetch" href="/assets/js/10.d195f939.js"><link rel="prefetch" href="/assets/js/11.dd42e2a6.js"><link rel="prefetch" href="/assets/js/12.ee2c872c.js"><link rel="prefetch" href="/assets/js/13.788181fe.js"><link rel="prefetch" href="/assets/js/14.923b40d7.js"><link rel="prefetch" href="/assets/js/15.be1e8f2a.js"><link rel="prefetch" href="/assets/js/16.a5861f2e.js"><link rel="prefetch" href="/assets/js/17.0ca1cca8.js"><link rel="prefetch" href="/assets/js/18.3552af88.js"><link rel="prefetch" href="/assets/js/19.d0b598dd.js"><link rel="prefetch" href="/assets/js/20.312fba46.js"><link rel="prefetch" href="/assets/js/21.de99e5de.js"><link rel="prefetch" href="/assets/js/22.4cb1ef09.js"><link rel="prefetch" href="/assets/js/23.2e9ea85a.js"><link rel="prefetch" href="/assets/js/24.1cd100b8.js"><link rel="prefetch" href="/assets/js/25.c17ed571.js"><link rel="prefetch" href="/assets/js/26.cee42a14.js"><link rel="prefetch" href="/assets/js/27.34b9e8bb.js"><link rel="prefetch" href="/assets/js/28.a0fd1666.js"><link rel="prefetch" href="/assets/js/29.cc16a8ba.js"><link rel="prefetch" href="/assets/js/3.e2b53d75.js"><link rel="prefetch" href="/assets/js/30.4b4a9808.js"><link rel="prefetch" href="/assets/js/31.55d17ac2.js"><link rel="prefetch" href="/assets/js/32.e6285297.js"><link rel="prefetch" href="/assets/js/33.2cf9fcd0.js"><link rel="prefetch" href="/assets/js/34.549b5096.js"><link rel="prefetch" href="/assets/js/35.fd8c8f14.js"><link rel="prefetch" href="/assets/js/36.db162c08.js"><link rel="prefetch" href="/assets/js/37.f105831d.js"><link rel="prefetch" href="/assets/js/38.d42b82e0.js"><link rel="prefetch" href="/assets/js/39.eb81783f.js"><link rel="prefetch" href="/assets/js/4.2837b6be.js"><link rel="prefetch" href="/assets/js/40.87c4c789.js"><link rel="prefetch" href="/assets/js/41.fc9b4279.js"><link rel="prefetch" href="/assets/js/42.c9148681.js"><link rel="prefetch" href="/assets/js/43.dbe26f4f.js"><link rel="prefetch" href="/assets/js/44.b1d85a5c.js"><link rel="prefetch" href="/assets/js/45.5a1e6a7a.js"><link rel="prefetch" href="/assets/js/46.bd963e4a.js"><link rel="prefetch" href="/assets/js/47.f6e86edc.js"><link rel="prefetch" href="/assets/js/49.65ae461d.js"><link rel="prefetch" href="/assets/js/5.3f71247d.js"><link rel="prefetch" href="/assets/js/50.66be60b2.js"><link rel="prefetch" href="/assets/js/51.42b1c641.js"><link rel="prefetch" href="/assets/js/52.bb9f5b94.js"><link rel="prefetch" href="/assets/js/53.3ed95f43.js"><link rel="prefetch" href="/assets/js/54.b989fa99.js"><link rel="prefetch" href="/assets/js/55.7799c2bd.js"><link rel="prefetch" href="/assets/js/56.95e3d2fa.js"><link rel="prefetch" href="/assets/js/57.47649eef.js"><link rel="prefetch" href="/assets/js/58.c3ce9734.js"><link rel="prefetch" href="/assets/js/59.1e092fb4.js"><link rel="prefetch" href="/assets/js/6.ba15ebf3.js"><link rel="prefetch" href="/assets/js/60.ae57b5f2.js"><link rel="prefetch" href="/assets/js/61.68ecf247.js"><link rel="prefetch" href="/assets/js/62.42a2fc04.js"><link rel="prefetch" href="/assets/js/63.819b8db9.js"><link rel="prefetch" href="/assets/js/64.8034f4d3.js"><link rel="prefetch" href="/assets/js/65.fa291912.js"><link rel="prefetch" href="/assets/js/66.3db4dcf7.js"><link rel="prefetch" href="/assets/js/67.a66d7e55.js"><link rel="prefetch" href="/assets/js/68.cbaf17d3.js"><link rel="prefetch" href="/assets/js/7.6f9d368d.js"><link rel="prefetch" href="/assets/js/8.516fa0e1.js"><link rel="prefetch" href="/assets/js/9.f1946ce5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0dca6718.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container custom-page-class"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">Koala 's blog</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          Home
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/design/">
          设计模式
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/algorithm/">
          算法相关
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-submenu-selected"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          java相关
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/effectivejava/" class="sidebar-link">介绍</a></li><li><a href="/effectivejava/EffectiveJava001.html" class="active sidebar-link">创建和销毁对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava001.html#第一条-考虑用静态工厂方法代替构造器" class="sidebar-link">第一条: 考虑用静态工厂方法代替构造器</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava001.html#第二条：遇到多个构造器参数时要考虑用构造器" class="sidebar-link">第二条：遇到多个构造器参数时要考虑用构造器</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava001.html#第三条：用私有构造器或枚举类型强化singleton属性" class="sidebar-link">第三条：用私有构造器或枚举类型强化Singleton属性</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava001.html#第四条：通过私有构造器强化不可实例化的能力" class="sidebar-link">第四条：通过私有构造器强化不可实例化的能力</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava001.html#第五条：避免创建不必要的对象" class="sidebar-link">第五条：避免创建不必要的对象</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava001.html#第六条：消除过期的对象引用" class="sidebar-link">第六条：消除过期的对象引用</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava001.html#第七条：避免使用终结方法" class="sidebar-link">第七条：避免使用终结方法</a></li></ul></li><li><a href="/effectivejava/EffectiveJava002.html" class="sidebar-link">对于所有对象都通用的方法</a></li><li><a href="/effectivejava/EffectiveJava003.html" class="sidebar-link">类和接口</a></li><li><a href="/effectivejava/EffectiveJava004.html" class="sidebar-link">泛型</a></li><li><a href="/effectivejava/EffectiveJava005.html" class="sidebar-link">枚举和注解</a></li><li><a href="/effectivejava/EffectiveJava006.html" class="sidebar-link">方法</a></li><li><a href="/effectivejava/EffectiveJava007.html" class="sidebar-link">通用程序设计</a></li><li><a href="/effectivejava/EffectiveJava008.html" class="sidebar-link">异常</a></li><li><a href="/effectivejava/EffectiveJava009.html" class="sidebar-link">并发</a></li><li><a href="/effectivejava/EffectiveJava010.html" class="sidebar-link">序列化</a></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="第一条-考虑用静态工厂方法代替构造器"><a href="#第一条-考虑用静态工厂方法代替构造器" aria-hidden="true" class="header-anchor">#</a> 第一条: 考虑用静态工厂方法代替构造器</h2> <h3 id="优势"><a href="#优势" aria-hidden="true" class="header-anchor">#</a> 优势</h3> <ul><li>静态工厂方法与构造器不同的第一大优势，它们有名字</li> <li>静态工厂方法与构造器不同的第二大优势在于，不必在每次调用它们的时候都创建一个新对象</li> <li>静态工厂方法与构造器不同的第三大优势在于，它们可以原返回类型的任何子类型的对象</li> <li>静态工厂方法与构造器不同的第四大优势在于，它们使代码变得更加简洁</li></ul> <h3 id="缺点"><a href="#缺点" aria-hidden="true" class="header-anchor">#</a> 缺点</h3> <ul><li>类如果不含公有的或者受保护的构造器，就不能被子类化</li> <li>它们与其他的静态方法实际上没有任何区别</li></ul> <h3 id="静态工厂的惯用名称"><a href="#静态工厂的惯用名称" aria-hidden="true" class="header-anchor">#</a> 静态工厂的惯用名称</h3> <ul><li><strong>valueOf</strong>： 该方法返回的实例与它的参数具有相同的值</li> <li><strong>of</strong>： valueOf的一种更为简洁的替代</li> <li><strong>getInstance</strong> ： 返回的实例是通过方法的参数来描述的，但是不能够说与参数具有同样的值。对于Singleton来说，该方法没有参数，并返回唯一的实例</li> <li><strong>newInstance</strong> ： 像getInstance一样，但newInstance可以确保返回的每个实例都与所有其他实例不同</li> <li><strong>getType</strong> ： 像getInstance一样，但是在工厂方法处于不同的类中的时候使用，Type 表示工厂方法所返回的对象类型</li> <li><strong>newType</strong>： 像getInstance一样，但是在工厂方法处于不同的类中国的时候使用，Type 表示工厂方法所返回的对象类型</li></ul> <h2 id="第二条：遇到多个构造器参数时要考虑用构造器"><a href="#第二条：遇到多个构造器参数时要考虑用构造器" aria-hidden="true" class="header-anchor">#</a> 第二条：遇到多个构造器参数时要考虑用构造器</h2> <blockquote><p>注：如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是不错的选择</p></blockquote> <h2 id="第三条：用私有构造器或枚举类型强化singleton属性"><a href="#第三条：用私有构造器或枚举类型强化singleton属性" aria-hidden="true" class="header-anchor">#</a> 第三条：用私有构造器或枚举类型强化Singleton属性</h2> <h3 id="第一种方法"><a href="#第一种方法" aria-hidden="true" class="header-anchor">#</a> 第一种方法</h3> <blockquote><p>公有静态成员是一个final域，私有构造器仅被调用一次，用来实例化公有的静态final域Elvis.INSTANCE。由于缺少公有的或者受保护的构造器，所以保证了Elvis的全局唯一性：一旦Elvis类被实例化，只会存在一个Elvis实例。客户端的任何行为都不会改变这一点。但是，享有特权的客户端可以借助AccessibleObject.setAccessible方法，通过反射机制调用私有构造器。如果需要抵御这种攻击。可以修改构造器，让它在被要求创建第二个实例的时候抛出异常</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>    public class Elvis<span class="token punctuation">{</span>

        public static final Elvis INSTANCE <span class="token operator">=</span> new Elvis<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       
        private Elvis<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
</code></pre></div><h3 id="第二种方法"><a href="#第二种方法" aria-hidden="true" class="header-anchor">#</a> 第二种方法</h3> <blockquote><p>在实现Singleton的第二种方法中，公有的成员是个静态工厂方法。对于静态方法Elvis.getInstance的所有调用，都会返回同一对象引用，所以永远不会创建其他的Elvis实例</p></blockquote> <p><strong>公有域方法的主要好处在于，组成类的成员的声明很清楚地表明了这个类是一个Singleton：公有的静态域是final的，所以该域将总是包含相同的对象引用。公有域方法在性能上不再由任何优势：现代的JVM实现几乎都能将静态工厂方法的调用内联化</strong></p> <p><strong>工厂方法的优势之一在于，它提供了灵活性：在不改变其API的前提下，我们可以改变该类是否应该为Singleton的想法，工厂方法返回该类的唯一实例，但是，它可以很容易修改，比如改成为每个调用该方法的线程返回一个唯一的实例，第二个优势与泛型有关。这些优势之间通常都不想关，public域的方法比较简单</strong></p> <blockquote><p>为了使利用这其中一种方法实现的Singleton类变成是可序列化的（Serializable），仅仅在声明中加上&quot;implements Serializable&quot;是不够的，为了维护并保证Singleton，必须声明所有实例域都是瞬时（transient）的，并提供一个readResolve方法。否则，每次反序列化一个序列化的实例时，都会创建一个新的实例，为了防止这种情况，要在Elvis类中加入下面这个readResolve方法：</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>    private Object  readResolve<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h3 id="第三种方法"><a href="#第三种方法" aria-hidden="true" class="header-anchor">#</a> 第三种方法</h3> <blockquote><p>编写一个包含单个元素的枚举类型，这种方法在功能上与公有域方法相近，但是更加简洁，无偿提供了序列化机制，绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>    public class Elvis<span class="token punctuation">{</span>
        
        private static final Elvis INSTANCE <span class="token operator">=</span> new Elvis<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        private Elvis<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">..</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>

        public static Elvis getInstance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>  


    public enum Elvis<span class="token punctuation">{</span>
        INSTANCE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="第四条：通过私有构造器强化不可实例化的能力"><a href="#第四条：通过私有构造器强化不可实例化的能力" aria-hidden="true" class="header-anchor">#</a> 第四条：通过私有构造器强化不可实例化的能力</h2> <blockquote><p>对于一些只包含静态方法和静态域的类，这样的类不希望被实例化，实例化对它没有任何意义，有一些简单的习惯用法可以确保类不可被实例化，由于只有当类不包含显式的构造器时，编译器参会生成缺省的构造器，因此我们只要让类包含私有构造器，它就不能被实例化</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>    public class UtilityClass<span class="token punctuation">{</span>
        private UtilityClass<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            throw new AssertionError<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>由于显式的构造器是私有的，所以不可以在该类的外部访问它。AssertionError不是必须的，但是他可以避免在类的内部调用构造器。它确保了该类在任何情况下都不会被实例化</p> <h2 id="第五条：避免创建不必要的对象"><a href="#第五条：避免创建不必要的对象" aria-hidden="true" class="header-anchor">#</a> 第五条：避免创建不必要的对象</h2> <h3 id="不可变的对象重用"><a href="#不可变的对象重用" aria-hidden="true" class="header-anchor">#</a> 不可变的对象重用</h3> <blockquote><p>一般来说。最好能重用对象而不是在每次需要的时候创建一个相同功能的新对象。重用方式既快速，又流行。如果对象是不变的（immutable），它就始终可以被重用</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>String s <span class="token operator">=</span> new String<span class="token punctuation">(</span><span class="token string">&quot;stringette&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>该语句每次被执行的时候都创建一个新的String实例，但是这些创建对象的动作全都是不必要的。传递给String构造器的参数(&quot;stringette&quot;)本身就是一个String实例，功能方面等同于构造器创建的所有对象</p> <p><strong>改造后：</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>String s <span class="token operator">=</span> <span class="token string">&quot;stringette&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>这个版本只用了一个String实例，而不是每次执行的时候都创建一个新的实例，而且它可以保证，对于所有同一台虚拟机中运行的代码，只要它们包含相同的字符串字面常量，该对象就会被重用</p> <p>对于同时提供了静态工厂方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。例如，**静态工厂方法Boolean.valueOf(String)几乎总是优先于构造器Boolean(String)。**构造器在每次被调用的时候都会创建一个新的对象，而静态工厂方法则从来不要求这样做，实际上也不会这样做</p> <h3 id="不会被修改的对象"><a href="#不会被修改的对象" aria-hidden="true" class="header-anchor">#</a> 不会被修改的对象</h3> <p><strong>反例：</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>    public class Person<span class="token punctuation">{</span>
        
        private final Date birthDate<span class="token punctuation">;</span>

        public boolean isBabyBoomer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            Calendar gmtCal <span class="token operator">=</span> Calendar.getInstance<span class="token punctuation">(</span>TimeZone.getTimeZome<span class="token punctuation">(</span><span class="token string">&quot;GMT&quot;</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
            gmtCal.set<span class="token punctuation">(</span>1946, Calendar.JANUARY, 1, 0, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Date boomStart <span class="token operator">=</span> gmtCal.getTime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            gmtCal.set<span class="token punctuation">(</span>1965, Calendar.JANUARY, 1, 0, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Date boomEnd <span class="token operator">=</span> gmtCal.getTime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> birthDate.compareTo<span class="token punctuation">(</span>boomStart<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> 0 <span class="token operator">&amp;&amp;</span> birthDate.compareTo<span class="token punctuation">(</span>boomEnd<span class="token punctuation">)</span> <span class="token operator">&lt;</span> 0
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>isBabyBoomer每次被调用的时候，都会新建一个Calendar、一个TimeZone和两个Date实例，这是不必要的。</p> <p><strong>改版后：</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>    public class Person<span class="token punctuation">{</span>
        
        private final Date birthDate<span class="token punctuation">;</span>
        
        private static final Date BOOM_START<span class="token punctuation">;</span>
        
        private static final Date BOOM_END<span class="token punctuation">;</span>

        static<span class="token punctuation">{</span>
            Calendar gmtCal <span class="token operator">=</span> Calendar.getInstance<span class="token punctuation">(</span>TimeZone.getTimeZome<span class="token punctuation">(</span><span class="token string">&quot;GMT&quot;</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
            gmtCal.set<span class="token punctuation">(</span>1946, Calendar.JANUARY, 1, 0, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Date boomStart <span class="token operator">=</span> gmtCal.getTime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            gmtCal.set<span class="token punctuation">(</span>1965, Calendar.JANUARY, 1, 0, 0, 0<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Date boomEnd <span class="token operator">=</span> gmtCal.getTime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        public boolean isBabyBoomer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
             <span class="token keyword">return</span> birthDate.compareTo<span class="token punctuation">(</span>boomStart<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> 0 <span class="token operator">&amp;&amp;</span> birthDate.compareTo<span class="token punctuation">(</span>boomEnd<span class="token punctuation">)</span> <span class="token operator">&lt;</span> 0
        <span class="token punctuation">}</span>

    <span class="token punctuation">}</span>
</code></pre></div><p>改版后的的Person类只在初始化的时候创建Calendar、TimeZone和Date实例一次，而不是在每次调用isBabyBoomer的时候都创建这些实例</p> <h3 id="自动装箱"><a href="#自动装箱" aria-hidden="true" class="header-anchor">#</a> 自动装箱</h3> <blockquote><p>在java 1.5发行版本中，有一种创建多余对象的新方法，称作自动装箱（autoboxing），它允许程序员将基本类型和装箱基本类型（Boxed Primtive Type）混用，按需要自动装箱和拆箱。自动装箱使得基本类型和装箱基本类型之间的差别变得模糊起来，但是并没有完全消除。</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>    public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>
        Long <span class="token function">sum</span> <span class="token operator">=</span> 0L<span class="token punctuation">;</span>
        for<span class="token punctuation">(</span>long i <span class="token operator">=</span> 0<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> Integer.MAX_VALUE<span class="token punctuation">;</span> i++<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">sum</span> +<span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        System.out.println<span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>上面的程序计算结果是正确的，但是比实际情况要更慢一些，只因为打错了一个字符，变量sum被声明成Long而不是long，意味着程序造了大约2^31个多余的Long实例（大约每次往Long sum中增加long时构造一个实例）。将sum的声明从Long改成long。</p> <blockquote><p>结论：要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱</p></blockquote> <h2 id="第六条：消除过期的对象引用"><a href="#第六条：消除过期的对象引用" aria-hidden="true" class="header-anchor">#</a> 第六条：消除过期的对象引用</h2> <p><strong>反例：</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>    public class Stack<span class="token punctuation">{</span>
        
        private Object<span class="token punctuation">[</span><span class="token punctuation">]</span> elements<span class="token punctuation">;</span>
        
        private int size <span class="token operator">=</span> 0<span class="token punctuation">;</span>
        
        private static final int DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> 16<span class="token punctuation">;</span>

        public Stack<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            elements <span class="token operator">=</span> new Object<span class="token punctuation">[</span>DEFAULT_INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        public void pop<span class="token punctuation">(</span>Object e<span class="token punctuation">)</span><span class="token punctuation">{</span>
            ensureCapacity<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            elements<span class="token punctuation">[</span>size++<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        public void push<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            if<span class="token punctuation">(</span>size <span class="token operator">==</span> 0<span class="token punctuation">)</span>
                throw new EmptyStackExcption<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> elements<span class="token punctuation">[</span>--size<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        private void ensureCapacity<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            if<span class="token punctuation">(</span>elements.length <span class="token operator">==</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>
                elements <span class="token operator">=</span> Arrays.copyOf<span class="token punctuation">(</span> elements, 2 * size + 1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>在例子中程序没有明显的错误，无论怎么测试都可以成功通过，但是它隐藏着一个问题-内存泄漏，随着垃圾回收的增加，或者由于内存占用的不断增加，程序性能的降低会逐渐表现出来，在极端的情况下，这种内存泄漏会导致磁盘交换（Disk Paging），甚至导致程序失败（OutOfMemoryError错误）</p> <p>在栈内部维护着对象的过期引用（obsolete reference）。所谓的过期引用，是指永远也不会再被解除的引用。在本例中，凡是在elements数组的“活动部分”之外的任何引用都是过期的</p> <p><strong>改进版本：</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>    public Obect pop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        if<span class="token punctuation">(</span>size <span class="token operator">==</span> 0<span class="token punctuation">)</span>
            throw new EmptyStackException<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Object result <span class="token operator">=</span> elements<span class="token punctuation">[</span>--size<span class="token punctuation">]</span><span class="token punctuation">;</span>
        elements<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span> //删除引用
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="第七条：避免使用终结方法"><a href="#第七条：避免使用终结方法" aria-hidden="true" class="header-anchor">#</a> 第七条：避免使用终结方法</h2> <blockquote><p>终结方法（finalizer）通常是不可预测的，也是很危险的。一般情况下是不必要的。使用终结方法会导致行为不稳定、降低性能，以及可移植性问题</p></blockquote> <p><strong>终结方法的缺点在于不能保证会被及时地执行</strong>。从一个对象变得不可到达开始到它的终结方法被执行，所花费的这段时间是任意长的，这意味着。注重时间（time-critical）的任务不应该由终结方法来完成。例如：<strong>用终结方法来关闭已经打开的文件，这是严重错误</strong>，因为打开文件的描述符是一种很有限的资源。由于JVM会延迟执行终结方法，所以大量的文件会保留在打开的状态，当一个程序再不能打开文件的时候，它可能会运行失败
及时地执行终结方法正是垃圾回收算法的一个主要功能，这种算法在不同的JVM实现中会大相径庭，如果程序依赖于终结方法被执行的时间点，那么这个程序的行为在不同的JVM中运行的表现可能就会截然不同。一个程序在你测试用的JVM平台上运行得非常好，而在其他JVM平台上却根本无法运行。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/effectivejava/" class="prev router-link-active"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        介绍
      </a></span> <span class="next"><a href="/effectivejava/EffectiveJava002.html">
        对于所有对象都通用的方法
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.193c9b61.js" defer></script><script src="/assets/js/2.be286493.js" defer></script><script src="/assets/js/48.bdbc5c65.js" defer></script>
  </body>
</html>