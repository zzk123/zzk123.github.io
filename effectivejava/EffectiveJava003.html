<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>类和接口 | Koala &#39;s blog</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    <meta name="description" content="欢迎来到我的博客">
    <link rel="preload" href="/assets/css/0.styles.0dca6718.css" as="style"><link rel="preload" href="/assets/js/app.193c9b61.js" as="script"><link rel="preload" href="/assets/js/2.be286493.js" as="script"><link rel="preload" href="/assets/js/50.66be60b2.js" as="script"><link rel="prefetch" href="/assets/js/10.d195f939.js"><link rel="prefetch" href="/assets/js/11.dd42e2a6.js"><link rel="prefetch" href="/assets/js/12.ee2c872c.js"><link rel="prefetch" href="/assets/js/13.788181fe.js"><link rel="prefetch" href="/assets/js/14.923b40d7.js"><link rel="prefetch" href="/assets/js/15.be1e8f2a.js"><link rel="prefetch" href="/assets/js/16.a5861f2e.js"><link rel="prefetch" href="/assets/js/17.0ca1cca8.js"><link rel="prefetch" href="/assets/js/18.3552af88.js"><link rel="prefetch" href="/assets/js/19.d0b598dd.js"><link rel="prefetch" href="/assets/js/20.312fba46.js"><link rel="prefetch" href="/assets/js/21.de99e5de.js"><link rel="prefetch" href="/assets/js/22.4cb1ef09.js"><link rel="prefetch" href="/assets/js/23.2e9ea85a.js"><link rel="prefetch" href="/assets/js/24.1cd100b8.js"><link rel="prefetch" href="/assets/js/25.c17ed571.js"><link rel="prefetch" href="/assets/js/26.cee42a14.js"><link rel="prefetch" href="/assets/js/27.34b9e8bb.js"><link rel="prefetch" href="/assets/js/28.a0fd1666.js"><link rel="prefetch" href="/assets/js/29.cc16a8ba.js"><link rel="prefetch" href="/assets/js/3.e2b53d75.js"><link rel="prefetch" href="/assets/js/30.4b4a9808.js"><link rel="prefetch" href="/assets/js/31.55d17ac2.js"><link rel="prefetch" href="/assets/js/32.e6285297.js"><link rel="prefetch" href="/assets/js/33.2cf9fcd0.js"><link rel="prefetch" href="/assets/js/34.549b5096.js"><link rel="prefetch" href="/assets/js/35.fd8c8f14.js"><link rel="prefetch" href="/assets/js/36.db162c08.js"><link rel="prefetch" href="/assets/js/37.f105831d.js"><link rel="prefetch" href="/assets/js/38.d42b82e0.js"><link rel="prefetch" href="/assets/js/39.eb81783f.js"><link rel="prefetch" href="/assets/js/4.2837b6be.js"><link rel="prefetch" href="/assets/js/40.87c4c789.js"><link rel="prefetch" href="/assets/js/41.fc9b4279.js"><link rel="prefetch" href="/assets/js/42.c9148681.js"><link rel="prefetch" href="/assets/js/43.dbe26f4f.js"><link rel="prefetch" href="/assets/js/44.b1d85a5c.js"><link rel="prefetch" href="/assets/js/45.5a1e6a7a.js"><link rel="prefetch" href="/assets/js/46.bd963e4a.js"><link rel="prefetch" href="/assets/js/47.f6e86edc.js"><link rel="prefetch" href="/assets/js/48.bdbc5c65.js"><link rel="prefetch" href="/assets/js/49.65ae461d.js"><link rel="prefetch" href="/assets/js/5.3f71247d.js"><link rel="prefetch" href="/assets/js/51.42b1c641.js"><link rel="prefetch" href="/assets/js/52.bb9f5b94.js"><link rel="prefetch" href="/assets/js/53.3ed95f43.js"><link rel="prefetch" href="/assets/js/54.b989fa99.js"><link rel="prefetch" href="/assets/js/55.7799c2bd.js"><link rel="prefetch" href="/assets/js/56.95e3d2fa.js"><link rel="prefetch" href="/assets/js/57.47649eef.js"><link rel="prefetch" href="/assets/js/58.c3ce9734.js"><link rel="prefetch" href="/assets/js/59.1e092fb4.js"><link rel="prefetch" href="/assets/js/6.ba15ebf3.js"><link rel="prefetch" href="/assets/js/60.ae57b5f2.js"><link rel="prefetch" href="/assets/js/61.68ecf247.js"><link rel="prefetch" href="/assets/js/62.42a2fc04.js"><link rel="prefetch" href="/assets/js/63.819b8db9.js"><link rel="prefetch" href="/assets/js/64.8034f4d3.js"><link rel="prefetch" href="/assets/js/65.fa291912.js"><link rel="prefetch" href="/assets/js/66.3db4dcf7.js"><link rel="prefetch" href="/assets/js/67.a66d7e55.js"><link rel="prefetch" href="/assets/js/68.cbaf17d3.js"><link rel="prefetch" href="/assets/js/7.6f9d368d.js"><link rel="prefetch" href="/assets/js/8.516fa0e1.js"><link rel="prefetch" href="/assets/js/9.f1946ce5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0dca6718.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container custom-page-class"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">Koala 's blog</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          Home
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/design/">
          设计模式
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/algorithm/">
          算法相关
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-submenu-selected"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          java相关
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/effectivejava/" class="sidebar-link">介绍</a></li><li><a href="/effectivejava/EffectiveJava001.html" class="sidebar-link">创建和销毁对象</a></li><li><a href="/effectivejava/EffectiveJava002.html" class="sidebar-link">对于所有对象都通用的方法</a></li><li><a href="/effectivejava/EffectiveJava003.html" class="active sidebar-link">类和接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava003.html#第十三条：使类和成员的可访问性最小化" class="sidebar-link">第十三条：使类和成员的可访问性最小化</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava003.html#第十四条：在公有类中使用访问方法非公有域" class="sidebar-link">第十四条：在公有类中使用访问方法非公有域</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava003.html#第十五条：使可变性最小化" class="sidebar-link">第十五条：使可变性最小化</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava003.html#第十六条：复合优先于继承" class="sidebar-link">第十六条：复合优先于继承</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava003.html#第十七条：要么为继承而设计，并提供文档说明，要么就禁止继承" class="sidebar-link">第十七条：要么为继承而设计，并提供文档说明，要么就禁止继承</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava003.html#第十八条：接口优先于抽象类" class="sidebar-link">第十八条：接口优先于抽象类</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava003.html#第十九条：接口只用于定义类型" class="sidebar-link">第十九条：接口只用于定义类型</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava003.html#第二十条：类层次优于标签类" class="sidebar-link">第二十条：类层次优于标签类</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava003.html#第二十一条：用函数对象表示策略" class="sidebar-link">第二十一条：用函数对象表示策略</a></li><li class="sidebar-sub-header"><a href="/effectivejava/EffectiveJava003.html#第二十二条：优先考虑静态成员类" class="sidebar-link">第二十二条：优先考虑静态成员类</a></li></ul></li><li><a href="/effectivejava/EffectiveJava004.html" class="sidebar-link">泛型</a></li><li><a href="/effectivejava/EffectiveJava005.html" class="sidebar-link">枚举和注解</a></li><li><a href="/effectivejava/EffectiveJava006.html" class="sidebar-link">方法</a></li><li><a href="/effectivejava/EffectiveJava007.html" class="sidebar-link">通用程序设计</a></li><li><a href="/effectivejava/EffectiveJava008.html" class="sidebar-link">异常</a></li><li><a href="/effectivejava/EffectiveJava009.html" class="sidebar-link">并发</a></li><li><a href="/effectivejava/EffectiveJava010.html" class="sidebar-link">序列化</a></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="第十三条：使类和成员的可访问性最小化"><a href="#第十三条：使类和成员的可访问性最小化" aria-hidden="true" class="header-anchor">#</a> 第十三条：使类和成员的可访问性最小化</h2> <blockquote><p>尽可能地使每个类或成员不被外界访问</p></blockquote> <p>要区别设计良好的模块与设计不好的模块，最重要的因素在于，这个模块对于外部的其他模块而言，是否隐藏其内部数据和其他实现细节。设计良好的模块会隐藏所有的实现细节，把它的API与它的实现清晰地隔离开来，然后，模块之间只通过它们的API进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为<strong>信息隐藏</strong>或<strong>封装</strong>，是软件设计的基本原则之一</p> <p>Java程序设计语言提供了许多机制来协助信息隐藏。<strong>访问控制（access control）机制</strong>决定了类、接口和成员的可访问性（accessibility）。实体的可访问性是由该实体声明所在的位置，以及该实体声明中所出现的访问修饰符（private、protected和public）共同决定的，正确地使用这些修饰符对于实现信息隐藏是非常关键的</p> <h3 id="对于成员（域、方法、嵌套类和嵌套接口）有四种访问级别"><a href="#对于成员（域、方法、嵌套类和嵌套接口）有四种访问级别" aria-hidden="true" class="header-anchor">#</a> 对于成员（域、方法、嵌套类和嵌套接口）有四种访问级别</h3> <ul><li><strong>私有的（private）</strong>：只有在声明该成员的顶层类内部才可以访问这个成员</li> <li><strong>包级私有的（package-private）</strong>：声明该成员的包内部的任何类都可以访问这个成员。从技术上讲，它被称为&quot;缺省（default）访问级别&quot;,如果没有为成员指定访问修饰符，就采用这个访问级别</li> <li><strong>受保护的（protected）</strong>：声明该成员的类的子类可以访问这个成员，并且声明该成员的包内部的任何类也可以访问这个成员</li> <li><strong>公有的（public）</strong>：在任何地方都可以访问该成员</li></ul> <blockquote><p>补充：类具有公有的静态final数组域，或者返回这种域的访问方法，这几乎是错误的，如果类具有这样的域或者访问方法，客户端将能够修改数组中的内容，这是安全漏洞的一个常见根源：</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>    public static final Thing<span class="token punctuation">[</span><span class="token punctuation">]</span> VALUES <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">..</span>.<span class="token punctuation">}</span>
</code></pre></div><h2 id="第十四条：在公有类中使用访问方法非公有域"><a href="#第十四条：在公有类中使用访问方法非公有域" aria-hidden="true" class="header-anchor">#</a> 第十四条：在公有类中使用访问方法非公有域</h2> <div class="language-bash extra-class"><pre class="language-bash"><code>    class Point<span class="token punctuation">{</span>
        public double x<span class="token punctuation">;</span>
        public double y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>对于可变的类来说，应包含私有域和公有设值的方法（setter）的类代替如下</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    class Point<span class="token punctuation">{</span>
        private double x<span class="token punctuation">;</span>
        private double y<span class="token punctuation">;</span>

        public Point<span class="token punctuation">(</span>double x, double y<span class="token punctuation">)</span><span class="token punctuation">{</span>
            this.x <span class="token operator">=</span> x<span class="token punctuation">;</span>
            this.y <span class="token operator">=</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        public double getX<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        public double getY<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        public void setX<span class="token punctuation">(</span>double x<span class="token punctuation">)</span><span class="token punctuation">{</span>
            this.x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        public void setY<span class="token punctuation">(</span>double y<span class="token punctuation">)</span><span class="token punctuation">{</span>
            this.y <span class="token operator">=</span> y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="第十五条：使可变性最小化"><a href="#第十五条：使可变性最小化" aria-hidden="true" class="header-anchor">#</a> 第十五条：使可变性最小化</h2> <blockquote><p>不可变类只是其实例不能被修改的类，每个实例中所包含的所有信息必须在创建该实例的时候就提供，并在对象的整个生命周期（lifetime）内固定不变。java平台类库中包含许多不可变类，其中有String、基本类型的包装类、BigInteger和BigDecimal。存在不可变的类有许多理由：不可变的类比可变类更加易于设计、实现和使用。</p></blockquote> <h3 id="为了使类称为不可变，要遵循下面五条规则："><a href="#为了使类称为不可变，要遵循下面五条规则：" aria-hidden="true" class="header-anchor">#</a> 为了使类称为不可变，要遵循下面五条规则：</h3> <ul><li><strong>不要提供任何会修改对象状态的方法（也称mutator，即改变对象属性的方法）</strong></li> <li><strong>保证类不会被扩展</strong>：这样可以防止恶意的子类假装对象的状态已经改变，从而破坏该类的不可变行为，为了防止子类化，一般的做法是使这个类成为final的，还有另一种方法就是，让类的所有构造器都变成私有的或者包级私有的并添加公有的静态工厂（static factory）来代替公有的构造器</li> <li><strong>使所有的域都是final的</strong></li> <li><strong>使所有的域成为私有的</strong>：可以防止客户端获得访问被域引用额可变对象的权限，并防止客户端直接修改这些对象</li> <li><strong>确保对于任何可变组件的互斥访问</strong>：如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用，并且，永远不要用客户端提供的对象引用来初始化这样的域，也不要从任何访问方法（accessor）中返回该对象的引用</li></ul> <blockquote><p>不可变对象的优点：在于本质上线程安全，不要求同步，不仅可以被自由地共享，而且也可以共享内部信息，唯一的缺点是：对于每个不同的值都需要一个单独的对象</p></blockquote> <h2 id="第十六条：复合优先于继承"><a href="#第十六条：复合优先于继承" aria-hidden="true" class="header-anchor">#</a> 第十六条：复合优先于继承</h2> <p><strong>继承（指的实现继承（implementation inheritance）</strong>，一个类扩展另一个类）是实现代码重用的有力手段，但是并非永远是完成这项工作的最佳工具，使用不当会导致软件变得很脆弱</p> <p>与方法调用不同的是，继承打破了封装性。如子类依赖于其超类中特定功能的实现细节，超类的实现可能随着发行版本的不同有所变化，如果真的发生了变化，子类可能遭到破坏，因此子类必须要跟着其超类的更新而演变，除非超类是专门为了扩展而设计的，并且具有很好的文档说明</p> <p><strong>复合</strong>是指在新的类中增加一个私有域，引用现有类的一个实例，新类中的每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果，这被称为转发（forwarding），新类中的方法被称为转发方法（forwarding method）。这样地类将会非常稳固，它不依赖于现有类的实现细节，即使现有的类添加了新的方法，也不会影响新的类</p> <p>如果在适合于使用复合的地方使用了继承，则会不必要地暴露实现细节，这样得到的API会把你限制在原始的实现上，永远的限定了类的性能，更为严重的是，由于暴露了内部的细节，客户端就有可能直接访问这些内部细节</p> <blockquote><p>因此，虽然继承的功能非常强大，但是也存在诸多问题，因为它违背了封装原则，只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。即便如此，如果子类和超类处于不同的包中，并且超类并不是为了继承而设计的，那么继承将会导致脆弱性，为了避免这种脆弱性，可以使用复合和转发机制类代替继承，尤其是当存在适当的接口可以实现包装类的时候，包装类不仅比子类更加健壮，而且功能也更加强大</p></blockquote> <h2 id="第十七条：要么为继承而设计，并提供文档说明，要么就禁止继承"><a href="#第十七条：要么为继承而设计，并提供文档说明，要么就禁止继承" aria-hidden="true" class="header-anchor">#</a> 第十七条：要么为继承而设计，并提供文档说明，要么就禁止继承</h2> <h2 id="第十八条：接口优先于抽象类"><a href="#第十八条：接口优先于抽象类" aria-hidden="true" class="header-anchor">#</a> 第十八条：接口优先于抽象类</h2> <blockquote><p>Java程序设计语言提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。这两种机制之间最明显的区别在于，抽象类允许包含某些方法的实现，但是接口则不允许，一个更为重要的区别在于，为了实现由抽象类定义的类型，类必须称为抽象类的一个子类。任何一个类，只要它定义了所有必要的方法，并且遵守通用约定，他就被允许实现一个接口，而不管这个类是处于类层次（class hierarchy）的哪个位置。因为java只允许单继承，所以抽象类作为类型定义受到极大的限制</p></blockquote> <h2 id="第十九条：接口只用于定义类型"><a href="#第十九条：接口只用于定义类型" aria-hidden="true" class="header-anchor">#</a> 第十九条：接口只用于定义类型</h2> <blockquote><p>有一种接口被称为常量接口（constant interface），它不满足上面的条件，这种接口不包含任何方法，它只包含静态的final域，每个域都导出一个常量，使用了这些常量的类实现了这个接口，以避免用类名来修饰常量名，如下</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>    public interface PhysicalConstants<span class="token punctuation">{</span>
        static final double AVOGADROS_NUMBER <span class="token operator">=</span> 6.02214199e23<span class="token punctuation">;</span>

        static final double BOLTZMANN_CONSTANT <span class="token operator">=</span> 1.3806503e-23<span class="token punctuation">;</span>

        static final double ELECTRON_MASS <span class="token operator">=</span> 9.10938188e-31<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>常量接口模式是对接口的不良使用。类在内部使用某些常量，这纯粹是实现细节。实现常量接口，会导致把这样的实现细节泄漏到该类的导出API中吗，类实现常量接口，这对于这个类的用户来讲没有什么价值</p> <p>如果要导出常量，可以有几种合理的选择方案，如果这些常量与某个现有的类或者接口紧密相关，就应该把这些常量添加到这个类或者接口中如下；如果这些常量最好被看做枚举类型的成员，就应该用枚举类型（enum type）来导出这些常量；不然就应该使用不可实例化的工具类（utility class）来导出这些常量，总之，接口应该只被用来定义类型，它们不应该被用来导出常量</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    public class PhysicalConstants <span class="token punctuation">{</span>
        private PhysicalConstants<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span> 

        public static final double AVOGADROS_NUMBER <span class="token operator">=</span> 6.02214199e23<span class="token punctuation">;</span>

        public static final double BOLTZMANN_CONSTANT <span class="token operator">=</span> 1.3806503e-23<span class="token punctuation">;</span>

        public static final double ELECTRON_MASS <span class="token operator">=</span> 9.10938188e-31<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="第二十条：类层次优于标签类"><a href="#第二十条：类层次优于标签类" aria-hidden="true" class="header-anchor">#</a> 第二十条：类层次优于标签类</h2> <div class="language-bash extra-class"><pre class="language-bash"><code>    class Figure<span class="token punctuation">{</span>
        enum  Shape <span class="token punctuation">{</span> RECTANGLE, CIRCLE <span class="token punctuation">}</span><span class="token punctuation">;</span>

        final Shape shape<span class="token punctuation">;</span>

        double length<span class="token punctuation">;</span>

        double width<span class="token punctuation">;</span>

        double redius<span class="token punctuation">;</span>

        Figure<span class="token punctuation">(</span>double redius<span class="token punctuation">)</span><span class="token punctuation">{</span>
            shape <span class="token operator">=</span> Shape.CIRCLE<span class="token punctuation">;</span>
            this.redius <span class="token operator">=</span> redius<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        Figure<span class="token punctuation">(</span>double length, double width<span class="token punctuation">)</span><span class="token punctuation">{</span>
             shape <span class="token operator">=</span> Shape.RECTANGLE<span class="token punctuation">;</span>
             this.length <span class="token operator">=</span> length<span class="token punctuation">;</span>
             this.width <span class="token operator">=</span> width<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        double area<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            switch<span class="token punctuation">(</span>shape<span class="token punctuation">)</span><span class="token punctuation">{</span>
                case: RECTANGLE:
                    <span class="token keyword">return</span> length * width<span class="token punctuation">;</span>
                case: CIRCLE:
                    <span class="token keyword">return</span> Math.PI * <span class="token punctuation">(</span>redius * redius<span class="token punctuation">)</span><span class="token punctuation">;</span>
                default:
                    throw new AssertionError<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>这种标签类（tagged class）有着许多缺点。它们中充斥着样板代码，包括枚举声明、标签域以及条件语句，由于多个实现乱七八糟地挤在单个类中，破坏了可读性。内存占用也增加了，因为实例承担着属于其他风格的不相关的域，标签类过于冗长、容易出错，效率低下。</p> <p>面向对象的语言如java，提供了其他更好地方法类定义表示多种风格对象的单个数据类型：子类型化（subtyping），标签类正是类层次的一种简单的仿效，可以将上面代码转化为以下的实现方式</p> <div class="language-bash extra-class"><pre class="language-bash"><code>    abstract class Figure<span class="token punctuation">{</span>
        abstract double area<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    class Circle extends Figure<span class="token punctuation">{</span>
        final double radius<span class="token punctuation">;</span>

        Circle<span class="token punctuation">(</span>double radius<span class="token punctuation">)</span><span class="token punctuation">{</span>
            this.radius <span class="token operator">=</span> radius<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        double area<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> Math.PI * <span class="token punctuation">(</span> radius * radius<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    class Rectangle extends Figure<span class="token punctuation">{</span>

        final double length<span class="token punctuation">;</span>

        final double width<span class="token punctuation">;</span>

        Rectangle<span class="token punctuation">(</span>double length, double width<span class="token punctuation">)</span><span class="token punctuation">{</span>
            this.length <span class="token operator">=</span> length<span class="token punctuation">;</span>
            this.width <span class="token operator">=</span> width<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        double area<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> length * width<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>这个类层次纠正了前面提到标签类的所有缺点，简单而清楚，每个类型的实现都配有自己的类，这些类都没有受到不相关的数据域的拖累。所有的域都是final的，编译器确保每个类的构造器都初始化它的数据域，对于根类中声明的每个抽象方法，都确保有一个实现，这样杜绝了由于遗漏switch case而导致运行时失败的可能性。另一种好处在于，它们可以用来反映类型之间本质上的层次关系，有助于增强灵活性，并进行更好的编译时类型检查</p></blockquote> <h2 id="第二十一条：用函数对象表示策略"><a href="#第二十一条：用函数对象表示策略" aria-hidden="true" class="header-anchor">#</a> 第二十一条：用函数对象表示策略</h2> <h2 id="第二十二条：优先考虑静态成员类"><a href="#第二十二条：优先考虑静态成员类" aria-hidden="true" class="header-anchor">#</a> 第二十二条：优先考虑静态成员类</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/effectivejava/EffectiveJava002.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        对于所有对象都通用的方法
      </a></span> <span class="next"><a href="/effectivejava/EffectiveJava004.html">
        泛型
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.193c9b61.js" defer></script><script src="/assets/js/2.be286493.js" defer></script><script src="/assets/js/50.66be60b2.js" defer></script>
  </body>
</html>