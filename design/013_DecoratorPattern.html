<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>装饰模式 | Koala &#39;s blog</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    <meta name="description" content="欢迎来到我的博客">
    <link rel="preload" href="/assets/css/0.styles.0dca6718.css" as="style"><link rel="preload" href="/assets/js/app.193c9b61.js" as="script"><link rel="preload" href="/assets/js/2.be286493.js" as="script"><link rel="preload" href="/assets/js/29.cc16a8ba.js" as="script"><link rel="prefetch" href="/assets/js/10.d195f939.js"><link rel="prefetch" href="/assets/js/11.dd42e2a6.js"><link rel="prefetch" href="/assets/js/12.ee2c872c.js"><link rel="prefetch" href="/assets/js/13.788181fe.js"><link rel="prefetch" href="/assets/js/14.923b40d7.js"><link rel="prefetch" href="/assets/js/15.be1e8f2a.js"><link rel="prefetch" href="/assets/js/16.a5861f2e.js"><link rel="prefetch" href="/assets/js/17.0ca1cca8.js"><link rel="prefetch" href="/assets/js/18.3552af88.js"><link rel="prefetch" href="/assets/js/19.d0b598dd.js"><link rel="prefetch" href="/assets/js/20.312fba46.js"><link rel="prefetch" href="/assets/js/21.de99e5de.js"><link rel="prefetch" href="/assets/js/22.4cb1ef09.js"><link rel="prefetch" href="/assets/js/23.2e9ea85a.js"><link rel="prefetch" href="/assets/js/24.1cd100b8.js"><link rel="prefetch" href="/assets/js/25.c17ed571.js"><link rel="prefetch" href="/assets/js/26.cee42a14.js"><link rel="prefetch" href="/assets/js/27.34b9e8bb.js"><link rel="prefetch" href="/assets/js/28.a0fd1666.js"><link rel="prefetch" href="/assets/js/3.e2b53d75.js"><link rel="prefetch" href="/assets/js/30.4b4a9808.js"><link rel="prefetch" href="/assets/js/31.55d17ac2.js"><link rel="prefetch" href="/assets/js/32.e6285297.js"><link rel="prefetch" href="/assets/js/33.2cf9fcd0.js"><link rel="prefetch" href="/assets/js/34.549b5096.js"><link rel="prefetch" href="/assets/js/35.fd8c8f14.js"><link rel="prefetch" href="/assets/js/36.db162c08.js"><link rel="prefetch" href="/assets/js/37.f105831d.js"><link rel="prefetch" href="/assets/js/38.d42b82e0.js"><link rel="prefetch" href="/assets/js/39.eb81783f.js"><link rel="prefetch" href="/assets/js/4.2837b6be.js"><link rel="prefetch" href="/assets/js/40.87c4c789.js"><link rel="prefetch" href="/assets/js/41.fc9b4279.js"><link rel="prefetch" href="/assets/js/42.c9148681.js"><link rel="prefetch" href="/assets/js/43.dbe26f4f.js"><link rel="prefetch" href="/assets/js/44.b1d85a5c.js"><link rel="prefetch" href="/assets/js/45.5a1e6a7a.js"><link rel="prefetch" href="/assets/js/46.bd963e4a.js"><link rel="prefetch" href="/assets/js/47.f6e86edc.js"><link rel="prefetch" href="/assets/js/48.bdbc5c65.js"><link rel="prefetch" href="/assets/js/49.65ae461d.js"><link rel="prefetch" href="/assets/js/5.3f71247d.js"><link rel="prefetch" href="/assets/js/50.66be60b2.js"><link rel="prefetch" href="/assets/js/51.42b1c641.js"><link rel="prefetch" href="/assets/js/52.bb9f5b94.js"><link rel="prefetch" href="/assets/js/53.3ed95f43.js"><link rel="prefetch" href="/assets/js/54.b989fa99.js"><link rel="prefetch" href="/assets/js/55.7799c2bd.js"><link rel="prefetch" href="/assets/js/56.95e3d2fa.js"><link rel="prefetch" href="/assets/js/57.47649eef.js"><link rel="prefetch" href="/assets/js/58.c3ce9734.js"><link rel="prefetch" href="/assets/js/59.1e092fb4.js"><link rel="prefetch" href="/assets/js/6.ba15ebf3.js"><link rel="prefetch" href="/assets/js/60.ae57b5f2.js"><link rel="prefetch" href="/assets/js/61.68ecf247.js"><link rel="prefetch" href="/assets/js/62.42a2fc04.js"><link rel="prefetch" href="/assets/js/63.819b8db9.js"><link rel="prefetch" href="/assets/js/64.8034f4d3.js"><link rel="prefetch" href="/assets/js/65.fa291912.js"><link rel="prefetch" href="/assets/js/66.3db4dcf7.js"><link rel="prefetch" href="/assets/js/67.a66d7e55.js"><link rel="prefetch" href="/assets/js/68.cbaf17d3.js"><link rel="prefetch" href="/assets/js/7.6f9d368d.js"><link rel="prefetch" href="/assets/js/8.516fa0e1.js"><link rel="prefetch" href="/assets/js/9.f1946ce5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0dca6718.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container custom-page-class"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">Koala 's blog</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          Home
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item ant-menu-item-selected"><a href="/design/" class="router-link-active">
          设计模式
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/algorithm/">
          算法相关
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          java相关
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/design/001_Preface.html" class="sidebar-link">前言</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>创建者模式</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>结构性模式</span> <span class="arrow down"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/design/009_StructuralPattern.html" class="sidebar-link">介绍</a></li><li><a href="/design/010_AdapterPattern.html" class="sidebar-link">适配器模式</a></li><li><a href="/design/011_BridgePattern.html" class="sidebar-link">桥接模式</a></li><li><a href="/design/012_CompositePattern.html" class="sidebar-link">组合模式</a></li><li><a href="/design/013_DecoratorPattern.html" class="active sidebar-link">装饰模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#定义" class="sidebar-link">定义</a></li><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#结构图" class="sidebar-link">结构图</a></li><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#典型代码" class="sidebar-link">典型代码</a></li><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#实例：图形界面构件" class="sidebar-link">实例：图形界面构件</a></li><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#代码实现" class="sidebar-link">代码实现</a></li><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#透明装饰模式与半透明装饰模式" class="sidebar-link">透明装饰模式与半透明装饰模式</a></li><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#主要优点" class="sidebar-link">主要优点</a></li><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#主要缺点" class="sidebar-link">主要缺点</a></li><li class="sidebar-sub-header"><a href="/design/013_DecoratorPattern.html#适用场合" class="sidebar-link">适用场合</a></li></ul></li><li><a href="/design/014_FacadePattern.html" class="sidebar-link">外观模式</a></li><li><a href="/design/015_FlyweightPattern.html" class="sidebar-link">享元模式</a></li><li><a href="/design/016_ProxyPattern.html" class="sidebar-link">代理模式</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>行为性模式</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h2> <blockquote><p>装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为。装饰模式时一种用于替换继承的技术，它通过一种无须定义子类的方法来给对象动态添加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩充原有类的功能</p></blockquote> <h2 id="定义"><a href="#定义" aria-hidden="true" class="header-anchor">#</a> 定义</h2> <blockquote><p>装饰模式（Decorator Pattern）:动态地给一个对象增加一些额外地职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。装饰模式是一种对象结构型模式</p></blockquote> <h2 id="结构图"><a href="#结构图" aria-hidden="true" class="header-anchor">#</a> 结构图</h2> <p><a data-fancybox="" title="结构图" href="/pic/design/x6j3YFX.png"><img src="/pic/design/x6j3YFX.png" alt="结构图"></a></p> <p>在装饰模式中，为了让系统具有更好地灵活性和可扩展性，通常会定义一个抽象装饰类，而将具体地装饰类作为它的子类，如上结构图所示</p> <ol><li><p><strong>Component（抽象构件）</strong>：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法。它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作</p></li> <li><p><strong>ConcreteComponent（具体构件）</strong>：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给他额外的职责（方法）</p></li> <li><p><strong>Decorator（抽象装饰类）</strong>：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护了一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰目的</p></li> <li><p><strong>ConcreteDecorator（具体装饰类）</strong>：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，可以调用在抽象装饰类中定义的方法，并可以增加新的方法用于扩充对象的行为。</p></li></ol> <p>由于具体构件类和装饰类都实现了相同的抽象构件接口，因此装饰模式以对客户透明的方法动态地给一个对象附加上更多地责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类地情况下，将对象地功能加以扩展。</p> <h2 id="典型代码"><a href="#典型代码" aria-hidden="true" class="header-anchor">#</a> 典型代码</h2> <p><strong>抽象装饰类的设计（装饰模式的核心）</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	class Decorator implements Component<span class="token punctuation">{</span>
		
		private Component component<span class="token punctuation">;</span>		//维持一个对抽象构件对象的引用
		
		public Decorator<span class="token punctuation">(</span>Component component<span class="token punctuation">)</span><span class="token punctuation">{</span>
			this.component <span class="token operator">=</span> component<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		public void operation<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			component.operation<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			//调用原有业务方法
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>在抽象装饰类Decorator中定义了一个Component类型的对象component，维持了一个对抽象构件对象的引用，并可以通过构造方法或者Setting方法将一个Component类型的对象注入进来，同时由于Decorator类实现了抽象构件Component接口，因此需要实现在其中声明的业务方法operation（）。这里需要注意的是，在Decorator中并没有真正实现operation()方法，而只是调用原有的component对象的opertion()方法，它没有真正实施装饰，而是提供一个统一的接口，将具体装饰过程交给其子类完成</p> <p><strong>在Decorator的子类即具体装饰类中，将继承operation()方法并根据需要进行扩展，典型的具体装饰类代码如下</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	class ConcreteDecorator extends Decorator<span class="token punctuation">{</span>
		public ConcreteDecorator<span class="token punctuation">(</span>Component component<span class="token punctuation">)</span><span class="token punctuation">{</span>
			super<span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>	
		
		public void operation<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				//调用原有业务方法
			addedBehavior<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		//调用新增业务方法
		<span class="token punctuation">}</span>

		//新增业务方法
		public void addedBehavior<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token punctuation">..</span><span class="token punctuation">..</span>
		<span class="token punctuation">}</span>

	<span class="token punctuation">}</span>
</code></pre></div><p>在具体装饰类中可以调用到抽象装饰类的operation()方法，同时可以定义新的业务方法，如addedBehavior()</p> <p>由于在抽象装饰类Decorator中注入的是Component类型的对象，因此可以将一个具体构件对象注入其中，再通过具体装饰类来进行修饰；此外，还可以将一个已经装饰过的Decorator子类的对象再注入其中进行多次装饰，从而对原有的功能进行多次扩展</p> <h2 id="实例：图形界面构件"><a href="#实例：图形界面构件" aria-hidden="true" class="header-anchor">#</a> 实例：图形界面构件</h2> <h3 id="结构图-2"><a href="#结构图-2" aria-hidden="true" class="header-anchor">#</a> 结构图</h3> <p><a data-fancybox="" title="结构图" href="/pic/design/5tDnB82.png"><img src="/pic/design/5tDnB82.png" alt="结构图"></a></p> <p>在图中，Component充当抽象构件类，其子类Window,TextBox,ListBox充当具体构件，COmponent类的另一个子类ComponentDecorator充当抽象装饰类，ComponentDecorator的子类ScrollBarDecorator和BlackBorderDecorator充当具体装饰类</p> <h2 id="代码实现"><a href="#代码实现" aria-hidden="true" class="header-anchor">#</a> 代码实现</h2> <p><strong>抽象界面构件类：抽象构件类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	abstract class Component <span class="token punctuation">{</span>
		public abstract void display<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>窗口类：具体构建类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class Window extends Component <span class="token punctuation">{</span>
	
		@Override
		public void display<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;显示窗口!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>文本框类：具体构件类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class TextBox extends Component<span class="token punctuation">{</span>
	
		@Override
		public void display<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;显示文本框&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>列表框类：具体构件类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class ListBox extends Component <span class="token punctuation">{</span>
	
		@Override
		public void display<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;显示列表框&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>构件装饰类：抽象装饰类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class ComponentDecorator extends Component <span class="token punctuation">{</span>
	
		private Component component<span class="token punctuation">;</span> 	//维持对抽象构件类型对象的引用
		
		public ComponentDecorator<span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			this.component <span class="token operator">=</span> component<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		public void display<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			component.display<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>滚动条装饰类:具体装饰类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class ScrollBarDecorator extends ComponentDecorator <span class="token punctuation">{</span>
	
		public ScrollBarDecorator<span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			super<span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		public void display<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			this.setScrollBar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			super.display<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		public void setScrollBar<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;为构件增加滚动条&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>黑色边框装饰类：具体装饰类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class BlackBorderDecorator extends ComponentDecorator <span class="token punctuation">{</span>
	
		public BlackBorderDecorator<span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			super<span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	
		@Override
		public void display<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			this.setBlackBorder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			super.display<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		public void setBlackBorder<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;为构件增加黑色边框！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>客户端测试</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class Client <span class="token punctuation">{</span>
		
		public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			Component component, componentSB<span class="token punctuation">;</span>		//使用抽象构件定义
			component <span class="token operator">=</span> new Window<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>				//定义具体构件
			componentSB <span class="token operator">=</span> new ScrollBarDecorator<span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>	//定义装饰后的构件
			componentSB.display<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		public static void main2<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			Component component, componentSB, componentBB<span class="token punctuation">;</span> 		//全部使用抽象构件定义
			component <span class="token operator">=</span> new Window<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			componentSB <span class="token operator">=</span> new ScrollBarDecorator<span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>	
			componentBB <span class="token operator">=</span> new BlackBorderDecorator<span class="token punctuation">(</span>componentSB<span class="token punctuation">)</span><span class="token punctuation">;</span>//将装饰了一次之后的对象继续注入到另外一个装饰类中，进行二次装饰
			
			componentBB.display<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><h2 id="透明装饰模式与半透明装饰模式"><a href="#透明装饰模式与半透明装饰模式" aria-hidden="true" class="header-anchor">#</a> 透明装饰模式与半透明装饰模式</h2> <p><strong>1. 透明装饰模式</strong></p> <p>在透明装饰模式中，要求客户端完全针对抽象编程。装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端类说，具体构件和具体装饰对象没有任何区别。也就是应该使用如下代码：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>	Component c, c1<span class="token punctuation">;</span> //使用抽象构件类型定义对象
	c <span class="token operator">=</span> new ConcreteCompent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	c1 <span class="token operator">=</span> new ConcreteCompent<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><p>而不应该是</p> <div class="language-bash extra-class"><pre class="language-bash"><code>	ConcreteCompent c；			//使用具体构件类型定义对象
	ConcreteDecorator c1<span class="token punctuation">;</span>   	//使用具体装饰类型定义对象
	c <span class="token operator">=</span> new ConcreteCompent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	c1 <span class="token operator">=</span> new ConcreteDecorator<span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> 	
</code></pre></div><p>透明模式可以使得客户端透明地使用装饰之前地对象和装饰之后地对象，无须关心它们的区别；此外，还可以对一个已装饰过的对象进行多次装饰，得到更为复杂，功能更为强大的对象，在实现透明装饰模式时，要求具体装饰类的operation()方法覆盖抽象装饰类的operation(),除了调用原有的对象的operation()外还需呀调用新增的addedBehavior()方法类增加新行为</p> <p><strong>2. 半透明装饰模式</strong></p> <p>透明模式的设计难度较大，而且有时用户需要单独调用新增的业务方法。为了能够调用到新增方法，不得不用具体装饰类型来定义装饰装饰之后的对象，而具体构件类型还是可以使用抽象构件类型来定义的，这种装饰模式即为半透明装饰模式。也就是说对客户端而言，具体构件类型无须关系，是透明的。但是具体装饰类型必须是指定的，这是不透明的。如下</p> <div class="language-bash extra-class"><pre class="language-bash"><code>	Component c<span class="token punctuation">;</span> //使用抽象构件类型定义对象
	c <span class="token operator">=</span> new ConcreteCompent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


	ConcreteCompent c；			//使用具体构件类型定义对象
	c <span class="token operator">=</span> new ConcreteCompent<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也方便；但是最大的缺点就是不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。在实现半透明的装饰模式时，只需要在具体装饰类中增加一个独立的addBehavior()方法来封装相应的业务处理，由于客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用addBehavior()方法来扩展系统功能。</p> <h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <p>装饰模式降低了系统的耦合度，可以动态地增加或删除对象地职责，并使得需要装饰地具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。在软件开发中，装饰模式应用较为广泛，例如在Java IO中的输入流和输出流的设计，javax.swing包中一些图像界面构件的增强等地方都用了装饰模式</p> <h2 id="主要优点"><a href="#主要优点" aria-hidden="true" class="header-anchor">#</a> 主要优点</h2> <ol><li><p>对于扩展一个对象的功能，装饰模式比继承更为灵活性，不会导致类的个数急剧增加</p></li> <li><p>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以运行时选择不同的具体装饰类，从而实现不同的行为</p></li> <li><p>可以对一个对象进行多次装饰，通过不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象</p></li> <li><p>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合开闭原则</p></li></ol> <h2 id="主要缺点"><a href="#主要缺点" aria-hidden="true" class="header-anchor">#</a> 主要缺点</h2> <ol><li><p>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，一定程度上影响性能</p></li> <li><p>装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调式时寻找错误可能需要逐级排查，较为繁琐</p></li></ol> <h2 id="适用场合"><a href="#适用场合" aria-hidden="true" class="header-anchor">#</a> 适用场合</h2> <ol><li><p>在不影响其他对象的情况下，以动态透明的方式给单个对象添加职责</p></li> <li><p>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两种：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如final类）</p></li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">9/22/2020, 12:20:37 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/design/012_CompositePattern.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        组合模式
      </a></span> <span class="next"><a href="/design/014_FacadePattern.html">
        外观模式
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.193c9b61.js" defer></script><script src="/assets/js/2.be286493.js" defer></script><script src="/assets/js/29.cc16a8ba.js" defer></script>
  </body>
</html>