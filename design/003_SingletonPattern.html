<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>单例模式 | Koala &#39;s blog</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    <meta name="description" content="欢迎来到我的博客">
    <link rel="preload" href="/assets/css/0.styles.0dca6718.css" as="style"><link rel="preload" href="/assets/js/app.193c9b61.js" as="script"><link rel="preload" href="/assets/js/2.be286493.js" as="script"><link rel="preload" href="/assets/js/19.d0b598dd.js" as="script"><link rel="prefetch" href="/assets/js/10.d195f939.js"><link rel="prefetch" href="/assets/js/11.dd42e2a6.js"><link rel="prefetch" href="/assets/js/12.ee2c872c.js"><link rel="prefetch" href="/assets/js/13.788181fe.js"><link rel="prefetch" href="/assets/js/14.923b40d7.js"><link rel="prefetch" href="/assets/js/15.be1e8f2a.js"><link rel="prefetch" href="/assets/js/16.a5861f2e.js"><link rel="prefetch" href="/assets/js/17.0ca1cca8.js"><link rel="prefetch" href="/assets/js/18.3552af88.js"><link rel="prefetch" href="/assets/js/20.312fba46.js"><link rel="prefetch" href="/assets/js/21.de99e5de.js"><link rel="prefetch" href="/assets/js/22.4cb1ef09.js"><link rel="prefetch" href="/assets/js/23.2e9ea85a.js"><link rel="prefetch" href="/assets/js/24.1cd100b8.js"><link rel="prefetch" href="/assets/js/25.c17ed571.js"><link rel="prefetch" href="/assets/js/26.cee42a14.js"><link rel="prefetch" href="/assets/js/27.34b9e8bb.js"><link rel="prefetch" href="/assets/js/28.a0fd1666.js"><link rel="prefetch" href="/assets/js/29.cc16a8ba.js"><link rel="prefetch" href="/assets/js/3.e2b53d75.js"><link rel="prefetch" href="/assets/js/30.4b4a9808.js"><link rel="prefetch" href="/assets/js/31.55d17ac2.js"><link rel="prefetch" href="/assets/js/32.e6285297.js"><link rel="prefetch" href="/assets/js/33.2cf9fcd0.js"><link rel="prefetch" href="/assets/js/34.549b5096.js"><link rel="prefetch" href="/assets/js/35.fd8c8f14.js"><link rel="prefetch" href="/assets/js/36.db162c08.js"><link rel="prefetch" href="/assets/js/37.f105831d.js"><link rel="prefetch" href="/assets/js/38.d42b82e0.js"><link rel="prefetch" href="/assets/js/39.eb81783f.js"><link rel="prefetch" href="/assets/js/4.2837b6be.js"><link rel="prefetch" href="/assets/js/40.87c4c789.js"><link rel="prefetch" href="/assets/js/41.fc9b4279.js"><link rel="prefetch" href="/assets/js/42.c9148681.js"><link rel="prefetch" href="/assets/js/43.dbe26f4f.js"><link rel="prefetch" href="/assets/js/44.b1d85a5c.js"><link rel="prefetch" href="/assets/js/45.5a1e6a7a.js"><link rel="prefetch" href="/assets/js/46.bd963e4a.js"><link rel="prefetch" href="/assets/js/47.f6e86edc.js"><link rel="prefetch" href="/assets/js/48.bdbc5c65.js"><link rel="prefetch" href="/assets/js/49.65ae461d.js"><link rel="prefetch" href="/assets/js/5.3f71247d.js"><link rel="prefetch" href="/assets/js/50.66be60b2.js"><link rel="prefetch" href="/assets/js/51.42b1c641.js"><link rel="prefetch" href="/assets/js/52.bb9f5b94.js"><link rel="prefetch" href="/assets/js/53.3ed95f43.js"><link rel="prefetch" href="/assets/js/54.b989fa99.js"><link rel="prefetch" href="/assets/js/55.7799c2bd.js"><link rel="prefetch" href="/assets/js/56.95e3d2fa.js"><link rel="prefetch" href="/assets/js/57.47649eef.js"><link rel="prefetch" href="/assets/js/58.c3ce9734.js"><link rel="prefetch" href="/assets/js/59.1e092fb4.js"><link rel="prefetch" href="/assets/js/6.ba15ebf3.js"><link rel="prefetch" href="/assets/js/60.ae57b5f2.js"><link rel="prefetch" href="/assets/js/61.68ecf247.js"><link rel="prefetch" href="/assets/js/62.42a2fc04.js"><link rel="prefetch" href="/assets/js/63.819b8db9.js"><link rel="prefetch" href="/assets/js/64.8034f4d3.js"><link rel="prefetch" href="/assets/js/65.fa291912.js"><link rel="prefetch" href="/assets/js/66.3db4dcf7.js"><link rel="prefetch" href="/assets/js/67.a66d7e55.js"><link rel="prefetch" href="/assets/js/68.cbaf17d3.js"><link rel="prefetch" href="/assets/js/7.6f9d368d.js"><link rel="prefetch" href="/assets/js/8.516fa0e1.js"><link rel="prefetch" href="/assets/js/9.f1946ce5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0dca6718.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container custom-page-class"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">Koala 's blog</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          Home
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item ant-menu-item-selected"><a href="/design/" class="router-link-active">
          设计模式
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/algorithm/">
          算法相关
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          java相关
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/design/001_Preface.html" class="sidebar-link">前言</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>创建者模式</span> <span class="arrow down"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/design/002_CreativePattern.html" class="sidebar-link">介绍</a></li><li><a href="/design/003_SingletonPattern.html" class="active sidebar-link">单例模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#定义" class="sidebar-link">定义</a></li><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#结构图" class="sidebar-link">结构图</a></li><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#实例：负载均衡器的设计" class="sidebar-link">实例：负载均衡器的设计</a></li><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#饿汉式单例模式" class="sidebar-link">饿汉式单例模式</a></li><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#懒汉式单例模式" class="sidebar-link">懒汉式单例模式</a></li><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#饿汉式单例类与懒汉式单例类比较" class="sidebar-link">饿汉式单例类与懒汉式单例类比较</a></li><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#iodh" class="sidebar-link">IoDH</a></li><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#优点" class="sidebar-link">优点</a></li><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#缺点" class="sidebar-link">缺点</a></li><li class="sidebar-sub-header"><a href="/design/003_SingletonPattern.html#适用场景" class="sidebar-link">适用场景</a></li></ul></li><li><a href="/design/004_SimpleFactoryPattern.html" class="sidebar-link">简单工厂模式</a></li><li><a href="/design/005_FactoryMethodPattern.html" class="sidebar-link">工厂方法模式</a></li><li><a href="/design/006_AbstractFactoryPattern.html" class="sidebar-link">抽象工厂模式</a></li><li><a href="/design/007_PrototypePattern.html" class="sidebar-link">原型模式</a></li><li><a href="/design/008_BuilderPattern.html" class="sidebar-link">建造者模式</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>结构性模式</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>行为性模式</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="定义"><a href="#定义" aria-hidden="true" class="header-anchor">#</a> 定义</h2> <blockquote><p>单例模式（Singleton Pattern）:确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例是一种对象创建型模式</p></blockquote> <h2 id="结构图"><a href="#结构图" aria-hidden="true" class="header-anchor">#</a> 结构图</h2> <p><a data-fancybox="" title="结构图" href="/pic/design/F3DDXEI.png"><img src="/pic/design/F3DDXEI.png" alt="结构图"></a></p> <p><strong>Singleton（单例）</strong>：在单例类的内部实现只生成一个实例，同时它提供一个静态的GetInstance()方法，让客户可以访问它的唯一实例；为了防止在外部对单例类实例化，它的构造函数可见性为private；在单例类内部定义了一个Singleton类型的静态对象，作为供外部共享访问的唯一实例</p> <h3 id="要点"><a href="#要点" aria-hidden="true" class="header-anchor">#</a> 要点</h3> <ul><li>某个类只能有一个实例</li> <li>它必须自行创建这个实例</li> <li>它必须自行向整个系统提供这个实例</li></ul> <h2 id="实例：负载均衡器的设计"><a href="#实例：负载均衡器的设计" aria-hidden="true" class="header-anchor">#</a> 实例：负载均衡器的设计</h2> <h3 id="结构图-2"><a href="#结构图-2" aria-hidden="true" class="header-anchor">#</a> 结构图</h3> <p><a data-fancybox="" title="结构图" href="/pic/design/7pKv64v.png"><img src="/pic/design/7pKv64v.png" alt="结构图"></a></p> <h3 id="代码实现"><a href="#代码实现" aria-hidden="true" class="header-anchor">#</a> 代码实现</h3> <div class="language-bash extra-class"><pre class="language-bash"><code>class LoadBalancer<span class="token punctuation">{</span>
	
	private static LoadBalancer instance <span class="token operator">=</span> null<span class="token punctuation">;</span>

	private List serverList <span class="token operator">=</span> null<span class="token punctuation">;</span>

	private LoadBalancer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		serverList <span class="token operator">=</span> new ArrayList<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
	<span class="token punctuation">}</span>

	public static LoadBalancer getLoadBalancer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		if<span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
			instance <span class="token operator">=</span> new LoadBalancer<span class="token punctuation">;</span>	
		<span class="token punctuation">}</span>
		<span class="token keyword">return</span> instance<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	public void addServer<span class="token punctuation">(</span>String server<span class="token punctuation">)</span><span class="token punctuation">{</span>
		serverList.add<span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	public void removeServer<span class="token punctuation">(</span>String server<span class="token punctuation">)</span><span class="token punctuation">{</span>
		serverList.remove<span class="token punctuation">(</span>server<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
	public String getServer<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		Random random <span class="token operator">=</span> new Random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		int i <span class="token operator">=</span> random.nextInt<span class="token punctuation">(</span>serverList.size<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>String<span class="token punctuation">)</span>serverList.get<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="饿汉式单例模式"><a href="#饿汉式单例模式" aria-hidden="true" class="header-anchor">#</a> 饿汉式单例模式</h2> <blockquote><p>饿汉式单例模式是指在定义静态变量的时候实例化单例类，因此在类加载的时候就已经创建了单例对象</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>class EagerSingleton<span class="token punctuation">{</span>
	
	private static final EagerSingleton instance <span class="token operator">=</span> new EagerSingleton<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	private EagerSingleton<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

	public static EagerSingleton getInstance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token keyword">return</span> instance<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="懒汉式单例模式"><a href="#懒汉式单例模式" aria-hidden="true" class="header-anchor">#</a> 懒汉式单例模式</h2> <blockquote><p>懒汉式单例模式是指在第一次调用getInstance()方法时实例化单例，在类加载时不自行实例化，这种技术又称为延迟加载技术，即需要的时候再加载实例</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>//双重检查锁定<span class="token punctuation">(</span>Doublie-check Locking<span class="token punctuation">)</span>
class LazySingleton<span class="token punctuation">{</span>
		
	//使用volatile修饰的成员变量可以确保多个线程都能够正确处理
	private volatile static LazySingleton <span class="token operator">=</span> null<span class="token punctuation">;</span>

	private LazySingleton<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

	public static LazySingleton getInstance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		
		//第一重判断
		if<span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
			//锁定代码块
			synchronized<span class="token punctuation">(</span>LazySingleton.class<span class="token punctuation">)</span><span class="token punctuation">{</span>
				//第二重判断
				if<span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>
					instance <span class="token operator">=</span> new LazySingleton<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//创建单例实例
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
			
	<span class="token punctuation">}</span>
		
<span class="token punctuation">}</span>
</code></pre></div><h2 id="饿汉式单例类与懒汉式单例类比较"><a href="#饿汉式单例类与懒汉式单例类比较" aria-hidden="true" class="header-anchor">#</a> 饿汉式单例类与懒汉式单例类比较</h2> <ul><li><p><code>饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问的问题，可以确保实例的唯一性</code>；从调用速度和反应时间角度来说，由于单例对象一开始就得以创建，因此要由于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长</p></li> <li><p><code>懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载</code>，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的几率较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响</p></li></ul> <h2 id="iodh"><a href="#iodh" aria-hidden="true" class="header-anchor">#</a> IoDH</h2> <blockquote><p>在IoDH中，在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用</p></blockquote> <div class="language-bash extra-class"><pre class="language-bash"><code>class Singleton <span class="token punctuation">{</span>  
	private Singleton<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
	<span class="token punctuation">}</span>  
		
	private static class HolderClass <span class="token punctuation">{</span>  
			private final static Singleton instance <span class="token operator">=</span> new Singleton<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token punctuation">}</span>  
		
	public static Singleton getInstance<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
		<span class="token keyword">return</span> HolderClass.instance<span class="token punctuation">;</span>  
	<span class="token punctuation">}</span>  
		
	public static void main<span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
		Singleton s1, s2<span class="token punctuation">;</span>   
			s1 <span class="token operator">=</span> Singleton.getInstance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
		s2 <span class="token operator">=</span> Singleton.getInstance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
		System.out.println<span class="token punctuation">(</span>s1<span class="token operator">==</span>s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  
	<span class="token punctuation">}</span>  
<span class="token punctuation">}</span>  
</code></pre></div><p>创建的单例对象s1和s2为同一对象。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。</p> <h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <p>单例模式作为一种目标明确，结构简单，理解容易的设计模式，在软件开发中使用频繁非常高，在很多应用软件和框架中都得以广泛使用</p> <h2 id="优点"><a href="#优点" aria-hidden="true" class="header-anchor">#</a> 优点</h2> <ol><li><p><strong>单例模式提供了对唯一实例的受控访问</strong>。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它</p></li> <li><p>由于在系统内存中只存在一个对象，因此可以节约资源，对于一些需要频繁创建和销毁的对象，<strong>单例模式可以提高系统的性能</strong></p></li> <li><p><strong>允许可变数目的实例</strong>。基于单例模式，开发人员可以进行扩展，使用和控制单例对象相似的方法来获取指定个数的实例对象，既节约资源，又解决了由于单例对象共享过多有损性能的问题</p></li></ol> <h2 id="缺点"><a href="#缺点" aria-hidden="true" class="header-anchor">#</a> 缺点</h2> <ol><li><p>由于单例模式中没有抽象层，因此<strong>单例类的扩展有很大困难</strong></p></li> <li><p><strong>单例类的职责过重，在一定程度上违背了单一职责原则</strong>。因为单例类既提供了业务方法，又提供了创建对象的方法（工厂方法），将对象的创建和对象本身的功能耦合在一起</p></li> <li><p><strong>很多面向对象语言（如Java， C#）的运行环境都提供了自动垃圾回收技术，因此，如果实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致共享的单例对象状态的丢失</strong></p></li></ol> <h2 id="适用场景"><a href="#适用场景" aria-hidden="true" class="header-anchor">#</a> 适用场景</h2> <ol><li><p><strong>系统只需要一个实例对象</strong>。例如，系统要求提供了一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象</p></li> <li><p><strong>客户调用类的单个实例只允许使用一个公共访问点</strong>，除了该公共访问点，不能通过其他途径访问该实例</p></li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">9/22/2020, 12:20:37 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/design/002_CreativePattern.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        介绍
      </a></span> <span class="next"><a href="/design/004_SimpleFactoryPattern.html">
        简单工厂模式
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.193c9b61.js" defer></script><script src="/assets/js/2.be286493.js" defer></script><script src="/assets/js/19.d0b598dd.js" defer></script>
  </body>
</html>