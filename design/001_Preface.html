<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>前言 | Koala &#39;s blog</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    <meta name="description" content="欢迎来到我的博客">
    <link rel="preload" href="/assets/css/0.styles.0dca6718.css" as="style"><link rel="preload" href="/assets/js/app.193c9b61.js" as="script"><link rel="preload" href="/assets/js/2.be286493.js" as="script"><link rel="preload" href="/assets/js/17.0ca1cca8.js" as="script"><link rel="prefetch" href="/assets/js/10.d195f939.js"><link rel="prefetch" href="/assets/js/11.dd42e2a6.js"><link rel="prefetch" href="/assets/js/12.ee2c872c.js"><link rel="prefetch" href="/assets/js/13.788181fe.js"><link rel="prefetch" href="/assets/js/14.923b40d7.js"><link rel="prefetch" href="/assets/js/15.be1e8f2a.js"><link rel="prefetch" href="/assets/js/16.a5861f2e.js"><link rel="prefetch" href="/assets/js/18.3552af88.js"><link rel="prefetch" href="/assets/js/19.d0b598dd.js"><link rel="prefetch" href="/assets/js/20.312fba46.js"><link rel="prefetch" href="/assets/js/21.de99e5de.js"><link rel="prefetch" href="/assets/js/22.4cb1ef09.js"><link rel="prefetch" href="/assets/js/23.2e9ea85a.js"><link rel="prefetch" href="/assets/js/24.1cd100b8.js"><link rel="prefetch" href="/assets/js/25.c17ed571.js"><link rel="prefetch" href="/assets/js/26.cee42a14.js"><link rel="prefetch" href="/assets/js/27.34b9e8bb.js"><link rel="prefetch" href="/assets/js/28.a0fd1666.js"><link rel="prefetch" href="/assets/js/29.cc16a8ba.js"><link rel="prefetch" href="/assets/js/3.e2b53d75.js"><link rel="prefetch" href="/assets/js/30.4b4a9808.js"><link rel="prefetch" href="/assets/js/31.55d17ac2.js"><link rel="prefetch" href="/assets/js/32.e6285297.js"><link rel="prefetch" href="/assets/js/33.2cf9fcd0.js"><link rel="prefetch" href="/assets/js/34.549b5096.js"><link rel="prefetch" href="/assets/js/35.fd8c8f14.js"><link rel="prefetch" href="/assets/js/36.db162c08.js"><link rel="prefetch" href="/assets/js/37.f105831d.js"><link rel="prefetch" href="/assets/js/38.d42b82e0.js"><link rel="prefetch" href="/assets/js/39.eb81783f.js"><link rel="prefetch" href="/assets/js/4.2837b6be.js"><link rel="prefetch" href="/assets/js/40.87c4c789.js"><link rel="prefetch" href="/assets/js/41.fc9b4279.js"><link rel="prefetch" href="/assets/js/42.c9148681.js"><link rel="prefetch" href="/assets/js/43.dbe26f4f.js"><link rel="prefetch" href="/assets/js/44.b1d85a5c.js"><link rel="prefetch" href="/assets/js/45.5a1e6a7a.js"><link rel="prefetch" href="/assets/js/46.bd963e4a.js"><link rel="prefetch" href="/assets/js/47.f6e86edc.js"><link rel="prefetch" href="/assets/js/48.bdbc5c65.js"><link rel="prefetch" href="/assets/js/49.65ae461d.js"><link rel="prefetch" href="/assets/js/5.3f71247d.js"><link rel="prefetch" href="/assets/js/50.66be60b2.js"><link rel="prefetch" href="/assets/js/51.42b1c641.js"><link rel="prefetch" href="/assets/js/52.bb9f5b94.js"><link rel="prefetch" href="/assets/js/53.3ed95f43.js"><link rel="prefetch" href="/assets/js/54.b989fa99.js"><link rel="prefetch" href="/assets/js/55.7799c2bd.js"><link rel="prefetch" href="/assets/js/56.95e3d2fa.js"><link rel="prefetch" href="/assets/js/57.47649eef.js"><link rel="prefetch" href="/assets/js/58.c3ce9734.js"><link rel="prefetch" href="/assets/js/59.1e092fb4.js"><link rel="prefetch" href="/assets/js/6.ba15ebf3.js"><link rel="prefetch" href="/assets/js/60.ae57b5f2.js"><link rel="prefetch" href="/assets/js/61.68ecf247.js"><link rel="prefetch" href="/assets/js/62.42a2fc04.js"><link rel="prefetch" href="/assets/js/63.819b8db9.js"><link rel="prefetch" href="/assets/js/64.8034f4d3.js"><link rel="prefetch" href="/assets/js/65.fa291912.js"><link rel="prefetch" href="/assets/js/66.3db4dcf7.js"><link rel="prefetch" href="/assets/js/67.a66d7e55.js"><link rel="prefetch" href="/assets/js/68.cbaf17d3.js"><link rel="prefetch" href="/assets/js/7.6f9d368d.js"><link rel="prefetch" href="/assets/js/8.516fa0e1.js"><link rel="prefetch" href="/assets/js/9.f1946ce5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0dca6718.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container custom-page-class"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">Koala 's blog</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          Home
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item ant-menu-item-selected"><a href="/design/" class="router-link-active">
          设计模式
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/algorithm/">
          算法相关
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          java相关
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/design/001_Preface.html" class="active sidebar-link">前言</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/001_Preface.html#定义" class="sidebar-link">定义</a></li><li class="sidebar-sub-header"><a href="/design/001_Preface.html#分类" class="sidebar-link">分类</a></li><li class="sidebar-sub-header"><a href="/design/001_Preface.html#常用的设计模式" class="sidebar-link">常用的设计模式</a></li><li class="sidebar-sub-header"><a href="/design/001_Preface.html#设计模式的作用" class="sidebar-link">设计模式的作用</a></li><li class="sidebar-sub-header"><a href="/design/001_Preface.html#面向对象设计原则" class="sidebar-link">面向对象设计原则</a></li></ul></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>创建者模式</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>结构性模式</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>行为性模式</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="定义"><a href="#定义" aria-hidden="true" class="header-anchor">#</a> 定义</h2> <p>设计模式就是一套被反复使用的，多数人知晓的，经过分类编目的，代码设计经验的总结，使用设计模式是为了可重用代码，让代码更容易被他人理解并且提高代码可靠性。</p> <p>设计模式一般包含<code>模式名称</code>，<code>问题</code>，<code>目的</code>，<code>解决方案</code>，<code>效果</code>等组成要素，其中关键要素是模式名称，问题，解决方案和效果。</p> <ul><li><p><code>模式名称</code>：通过一两个词来为模式命名</p></li> <li><p><code>问题</code>：描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因</p></li> <li><p><code>解决方案</code>：描述一个设计模式的组成部分，以及这些组成部分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码之间进行描述</p></li> <li><p><code>效果</code>：描述了模式的优缺点以及在使用模式时应权衡的问题。</p></li></ul> <h2 id="分类"><a href="#分类" aria-hidden="true" class="header-anchor">#</a> 分类</h2> <p>设计模式还可以分成<code>创建型</code>，<code>结构型</code>和<code>行为型</code>3种。</p> <div class="language- extra-class"><pre><code>1. 创建型模式主要是用于描述如何创建对象   

2. 结构型模式主要是用于描述如何实现类或对象的组合 
   
3. 行为型模式主要用于描述类或对象怎样交互以及怎样分类职责
</code></pre></div><blockquote><p>设计模式还可以根据主要用于处理类之间的关系还是处理对象之间的关系，分成<code>类模式</code>和<code>对象模式</code>。</p></blockquote> <h2 id="常用的设计模式"><a href="#常用的设计模式" aria-hidden="true" class="header-anchor">#</a> 常用的设计模式</h2> <h3 id="_1、创建型模式-creational-pattern"><a href="#_1、创建型模式-creational-pattern" aria-hidden="true" class="header-anchor">#</a> 1、创建型模式(Creational Pattern)</h3> <table><thead><tr><th>模式名称</th> <th style="text-align:left;">使用频率</th></tr></thead> <tbody><tr><td>单例模式(Singleton Pattern)</td> <td style="text-align:left;">4星</td></tr> <tr><td>简单工厂模式(Simple Factory Pattern)</td> <td style="text-align:left;">3星</td></tr> <tr><td>工厂方法模式(Factory Method Pattern)</td> <td style="text-align:left;">5星</td></tr> <tr><td>抽象工厂模式(Abstract Factory Pattern)</td> <td style="text-align:left;">5星</td></tr> <tr><td>原型模式(Prototype Pattern)</td> <td style="text-align:left;">3星</td></tr> <tr><td>建造者模式(Builder Pattern)</td> <td style="text-align:left;">2星</td></tr></tbody></table> <h3 id="_2、结构型模式-structural-pattern"><a href="#_2、结构型模式-structural-pattern" aria-hidden="true" class="header-anchor">#</a> 2、结构型模式(Structural Pattern)</h3> <table><thead><tr><th>模式名称</th> <th style="text-align:left;">使用频率</th></tr></thead> <tbody><tr><td>适配器模式(Adapter Pattern)</td> <td style="text-align:left;">4星</td></tr> <tr><td>桥接模式(Bridge Pattern)</td> <td style="text-align:left;">3星</td></tr> <tr><td>组合模式(Composite Pattern)</td> <td style="text-align:left;">4星</td></tr> <tr><td>装饰模式(Decorator Pattern)</td> <td style="text-align:left;">3星</td></tr> <tr><td>外观模式(Facade Pattern)</td> <td style="text-align:left;">5星</td></tr> <tr><td>享元模式(Flyweight Pattern)</td> <td style="text-align:left;">1星</td></tr> <tr><td>代理模式(Proxy Pattern)</td> <td style="text-align:left;">4星</td></tr></tbody></table> <h3 id="_3、行为型模式-behavior-pattern"><a href="#_3、行为型模式-behavior-pattern" aria-hidden="true" class="header-anchor">#</a> 3、行为型模式(Behavior Pattern)</h3> <table><thead><tr><th>模式名称</th> <th style="text-align:left;">使用频率</th></tr></thead> <tbody><tr><td>职责链模式(Chain of Responsibility Pattern)</td> <td style="text-align:left;">2星</td></tr> <tr><td>命令模式(Command Pattern)</td> <td style="text-align:left;">4星</td></tr> <tr><td>解释器模式(Interpreter Pattern)</td> <td style="text-align:left;">1星</td></tr> <tr><td>迭代器模式(Iterator Pattern)</td> <td style="text-align:left;">5星</td></tr> <tr><td>中介者模式(Mediator Pattern)</td> <td style="text-align:left;">2星</td></tr> <tr><td>备忘录模式(Memento Pattern)</td> <td style="text-align:left;">2星</td></tr> <tr><td>观察者模式(Observer Pattern)</td> <td style="text-align:left;">5星</td></tr> <tr><td>状态模式(State Pattern)</td> <td style="text-align:left;">3星</td></tr> <tr><td>策略模式(Strategy Pattern)</td> <td style="text-align:left;">4星</td></tr> <tr><td>模板方法模式(Template Method Pattern)</td> <td style="text-align:left;">3星</td></tr> <tr><td>访问者模式(Visitor Pattern)</td> <td style="text-align:left;">1星</td></tr></tbody></table> <h2 id="设计模式的作用"><a href="#设计模式的作用" aria-hidden="true" class="header-anchor">#</a> 设计模式的作用</h2> <ol><li><p><code>设计模式源于众多专家的经验和智慧</code>，他们是从许多优秀的软件系统中总结出的成功的，能够实现可维护性复用的设计方案，使用这些方案可避免做一些重复行的工作，有助于提高设计和开发效率</p></li> <li><p><code>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间的交流和沟通，使得设计方案更加通俗易懂</code></p></li> <li><p><code>大部分设计模式都兼顾了系统的可重用性和可扩展性</code>，这使得开发人员可以更好的重用一些已有的设计方案，功能模块甚至一个完整的软件系统。</p></li> <li><p><code>合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统</code></p></li> <li><p><code>学习设计模式将有助于初学者更加深入的理解面向对象思想</code>。例如，如何将代码分散在几个不同的类中？为什么要有“接口”？何谓针对抽象编程？何时不应该使用继承？如何不修改源代码增加新功能？同时还能更好的阅读和理解现有类库（如JDK）与其它系统中的源代码，早日脱离面向对象编程的菜鸟</p></li></ol> <h2 id="面向对象设计原则"><a href="#面向对象设计原则" aria-hidden="true" class="header-anchor">#</a> 面向对象设计原则</h2> <h3 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h3> <p>面向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或者源代码的重用，另一方面要确保系统能够易于扩展和修改，具有较好的灵活性。</p> <h3 id="最常见的7种面向对象设计原则："><a href="#最常见的7种面向对象设计原则：" aria-hidden="true" class="header-anchor">#</a> 最常见的7种面向对象设计原则：</h3> <table><thead><tr><th>设计原则名称</th> <th>定义</th> <th style="text-align:left;">使用频率</th></tr></thead> <tbody><tr><td>单一职责原则<br>(Single Responsibility Principle, SRP)</td> <td>一个类只负责一个功能领域中的相应职责</td> <td style="text-align:left;">4星</td></tr> <tr><td>开闭原则<br>（Open-Closed Principle,OCP）</td> <td>软件实体应对扩展开放，而对修改关闭</td> <td style="text-align:left;">5星</td></tr> <tr><td>里氏代换原则<br>（Liskov Substitution Principle, LSP）</td> <td>所有引用基类对象的地方能够透明地使用其子类的对象</td> <td style="text-align:left;">5星</td></tr> <tr><td>依赖倒转原则<br>（Depandence Segregation Principle, ISP）</td> <td>抽象不应该依赖于细节，细节应该依赖于抽象</td> <td style="text-align:left;">5星</td></tr> <tr><td>接口隔离原则<br>（Interface Segregation Principle，CRP）</td> <td>使用多个专门的接口，而不使用单一的总接口</td> <td style="text-align:left;">2星</td></tr> <tr><td>合成复合原则<br>(Composite Reuse Principle, CRP)</td> <td>尽量使用对象组合，而不是继承来达到复用的目的</td> <td style="text-align:left;">4星</td></tr> <tr><td>迪米特法则<br>（Law of Demeter，LoD）</td> <td>一个软件实体应当尽可能少地与其他实体发生相互作用</td> <td style="text-align:left;">3星</td></tr></tbody></table> <h3 id="单一职责原则"><a href="#单一职责原则" aria-hidden="true" class="header-anchor">#</a> 单一职责原则</h3> <p>单一职责原则是最简单的面向对象设计原则，它用于<code>控制类的粒度大小</code></p> <blockquote><p>单一职责原则：一个类只负责一个功能领域中的相应职责。或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p></blockquote> <p>单一职责原则结构图:</p> <p><a data-fancybox="" title="结构图" href="/pic/design/VrRACCc.png"><img src="/pic/design/VrRACCc.png" alt="结构图"></a></p> <h3 id="开闭原则"><a href="#开闭原则" aria-hidden="true" class="header-anchor">#</a> 开闭原则</h3> <p>开闭原则是面向对象的可复用设计的第一块基石。</p> <blockquote><p>开闭原则：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
24种设计模式中，大部分设计模式都符合开闭原则，在对每一个模式进行优缺点评价时，都会将开闭原则作为一个重要的评价依据，以判断基于该模式设计的系统是否具有良好的灵活性和可扩展性</p></blockquote> <h3 id="里氏代换原则"><a href="#里氏代换原则" aria-hidden="true" class="header-anchor">#</a> 里氏代换原则</h3> <p>里氏代换原则严格表述：如果对每一个类型为S的对象o1，都有类型为T的对象o2,使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有变化，那么类型S是类型T的子类型。</p> <blockquote><p>里氏代换原则：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p></blockquote> <h3 id="依赖倒转原则"><a href="#依赖倒转原则" aria-hidden="true" class="header-anchor">#</a> 依赖倒转原则</h3> <blockquote><p>依赖倒转原则：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。</p></blockquote> <p>依赖倒转原则要求在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明，参数类型声明，方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。</p> <p>在实现依赖转原则时，需要针对抽象层编程，而将具体类的对象通过依赖注入的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有3种，构造注入，设值注入（Setter注入）和接口注入。</p> <p>大多情况下，开闭原则，里氏代换原则和依赖倒转原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，相辅相成，相互补充，目标一致。</p> <p>开闭原则、里氏代换和依赖倒转（例子结构图）</p> <p><a data-fancybox="" title="结构图" href="/pic/design/PBIt1cw.png"><img src="/pic/design/PBIt1cw.png" alt="结构图"></a></p> <h3 id="接口隔离原则"><a href="#接口隔离原则" aria-hidden="true" class="header-anchor">#</a> 接口隔离原则</h3> <blockquote><p>接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些他不需要的接口。</p></blockquote> <p>根据接口隔离原则，当一个接口太大时，需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色.这里的‘接口’有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象，另一种是指某种语言具体的‘接口’定义，有严格的定义和结构，如java语言中的interface。</p> <h4 id="对于这两种含义，isp的表达方式和含义都有所不同"><a href="#对于这两种含义，isp的表达方式和含义都有所不同" aria-hidden="true" class="header-anchor">#</a> 对于这两种含义，ISP的表达方式和含义都有所不同</h4> <ol><li><p>当把‘接口’理解成一个类型所提供的所有方法特征的集合时，这是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时这个原则可以叫做‘<code>角色隔离原则</code>’</p></li> <li><p>如果把‘接口’理解为狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独接口，而不要提供大的接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方式应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为‘<code>定制服务</code>’，即为不同的客户端提供宽窄不同的接口。</p></li></ol> <h3 id="合成复合原则："><a href="#合成复合原则：" aria-hidden="true" class="header-anchor">#</a> 合成复合原则：</h3> <blockquote><p>合成复合原则又称为组合/聚合复用原则，尽量时候用对象组合，而不是继承来达到复用的目的。</p></blockquote> <p>合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分；新对象通过委派调用已有对象的方法达到复用功能的目的。简言之 <code>：复用时要尽量使用组合/聚合关系（关联关系），少用继承。</code></p> <p>在面对对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合关系，组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，应该严格遵循里氏代换原则，有效的使用继承会有助于对问题的理解，降低复杂度，而滥用继承，反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</p> <p>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而继承只能在有限的环境中使用（如果类没有声明为不能被继承）</p> <p>由于组合或聚合关系可以将已有的对象（也可以称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为黑箱复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性的调用对象的操作；合成复合可以在运行时动态进行，新对象可以动态引用与成员对象类型相同的其他对象。</p> <h3 id="迪米特法则"><a href="#迪米特法则" aria-hidden="true" class="header-anchor">#</a> 迪米特法则</h3> <blockquote><p>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用</p></blockquote> <p>迪米特法则要求限制软件实体之间通信的宽度和深度，迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p> <h4 id="迪米特法则还有几种定义形式：不要和-陌生人-说话，只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其-朋友-包括以下几类："><a href="#迪米特法则还有几种定义形式：不要和-陌生人-说话，只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其-朋友-包括以下几类：" aria-hidden="true" class="header-anchor">#</a> 迪米特法则还有几种定义形式：不要和‘陌生人’说话，只与你的直接朋友通信等，在迪米特法则中，对于一个对象，其‘朋友’包括以下几类：</h4> <div class="language- extra-class"><pre><code>1. 当前对象本身（this） 
                                
2. 以参数形式传入到当前对象方法中的对象	 
  
3. 当前对象的成员对象       

4. 如果当前对象的成员对象是一个集合，那么集合中元素也是朋友   
              
5. 当前对象所创建的对象    
</code></pre></div><p>任何一个对象，满足上面的条件之一，就是当前的朋友，否则就是陌生人，在应用迪米特法则时，一个对象只能与直接朋友进行交互，不要与陌生人发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p> <p>迪米特法则要求在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么两个对象就不应当发生任何直接的相互作用；如果其中一个对象需要调用另一个对象的方法，可以通过第三者转发这个调用，简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p> <blockquote><p>在将迪米特法则运用到系统设计中时，要注意下面几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度降低，就越有利于复用，一个处在松耦合的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p></blockquote></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">9/22/2020, 12:20:37 AM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/design/002_CreativePattern.html">
        介绍
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.193c9b61.js" defer></script><script src="/assets/js/2.be286493.js" defer></script><script src="/assets/js/17.0ca1cca8.js" defer></script>
  </body>
</html>