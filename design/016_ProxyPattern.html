<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>代理模式 | Koala &#39;s blog</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.5.0">
    <link rel="icon" href="/favicon.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.2/jquery.fancybox.min.css">
    <meta name="description" content="欢迎来到我的博客">
    <link rel="preload" href="/assets/css/0.styles.0dca6718.css" as="style"><link rel="preload" href="/assets/js/app.193c9b61.js" as="script"><link rel="preload" href="/assets/js/2.be286493.js" as="script"><link rel="preload" href="/assets/js/32.e6285297.js" as="script"><link rel="prefetch" href="/assets/js/10.d195f939.js"><link rel="prefetch" href="/assets/js/11.dd42e2a6.js"><link rel="prefetch" href="/assets/js/12.ee2c872c.js"><link rel="prefetch" href="/assets/js/13.788181fe.js"><link rel="prefetch" href="/assets/js/14.923b40d7.js"><link rel="prefetch" href="/assets/js/15.be1e8f2a.js"><link rel="prefetch" href="/assets/js/16.a5861f2e.js"><link rel="prefetch" href="/assets/js/17.0ca1cca8.js"><link rel="prefetch" href="/assets/js/18.3552af88.js"><link rel="prefetch" href="/assets/js/19.d0b598dd.js"><link rel="prefetch" href="/assets/js/20.312fba46.js"><link rel="prefetch" href="/assets/js/21.de99e5de.js"><link rel="prefetch" href="/assets/js/22.4cb1ef09.js"><link rel="prefetch" href="/assets/js/23.2e9ea85a.js"><link rel="prefetch" href="/assets/js/24.1cd100b8.js"><link rel="prefetch" href="/assets/js/25.c17ed571.js"><link rel="prefetch" href="/assets/js/26.cee42a14.js"><link rel="prefetch" href="/assets/js/27.34b9e8bb.js"><link rel="prefetch" href="/assets/js/28.a0fd1666.js"><link rel="prefetch" href="/assets/js/29.cc16a8ba.js"><link rel="prefetch" href="/assets/js/3.e2b53d75.js"><link rel="prefetch" href="/assets/js/30.4b4a9808.js"><link rel="prefetch" href="/assets/js/31.55d17ac2.js"><link rel="prefetch" href="/assets/js/33.2cf9fcd0.js"><link rel="prefetch" href="/assets/js/34.549b5096.js"><link rel="prefetch" href="/assets/js/35.fd8c8f14.js"><link rel="prefetch" href="/assets/js/36.db162c08.js"><link rel="prefetch" href="/assets/js/37.f105831d.js"><link rel="prefetch" href="/assets/js/38.d42b82e0.js"><link rel="prefetch" href="/assets/js/39.eb81783f.js"><link rel="prefetch" href="/assets/js/4.2837b6be.js"><link rel="prefetch" href="/assets/js/40.87c4c789.js"><link rel="prefetch" href="/assets/js/41.fc9b4279.js"><link rel="prefetch" href="/assets/js/42.c9148681.js"><link rel="prefetch" href="/assets/js/43.dbe26f4f.js"><link rel="prefetch" href="/assets/js/44.b1d85a5c.js"><link rel="prefetch" href="/assets/js/45.5a1e6a7a.js"><link rel="prefetch" href="/assets/js/46.bd963e4a.js"><link rel="prefetch" href="/assets/js/47.f6e86edc.js"><link rel="prefetch" href="/assets/js/48.bdbc5c65.js"><link rel="prefetch" href="/assets/js/49.65ae461d.js"><link rel="prefetch" href="/assets/js/5.3f71247d.js"><link rel="prefetch" href="/assets/js/50.66be60b2.js"><link rel="prefetch" href="/assets/js/51.42b1c641.js"><link rel="prefetch" href="/assets/js/52.bb9f5b94.js"><link rel="prefetch" href="/assets/js/53.3ed95f43.js"><link rel="prefetch" href="/assets/js/54.b989fa99.js"><link rel="prefetch" href="/assets/js/55.7799c2bd.js"><link rel="prefetch" href="/assets/js/56.95e3d2fa.js"><link rel="prefetch" href="/assets/js/57.47649eef.js"><link rel="prefetch" href="/assets/js/58.c3ce9734.js"><link rel="prefetch" href="/assets/js/59.1e092fb4.js"><link rel="prefetch" href="/assets/js/6.ba15ebf3.js"><link rel="prefetch" href="/assets/js/60.ae57b5f2.js"><link rel="prefetch" href="/assets/js/61.68ecf247.js"><link rel="prefetch" href="/assets/js/62.42a2fc04.js"><link rel="prefetch" href="/assets/js/63.819b8db9.js"><link rel="prefetch" href="/assets/js/64.8034f4d3.js"><link rel="prefetch" href="/assets/js/65.fa291912.js"><link rel="prefetch" href="/assets/js/66.3db4dcf7.js"><link rel="prefetch" href="/assets/js/67.a66d7e55.js"><link rel="prefetch" href="/assets/js/68.cbaf17d3.js"><link rel="prefetch" href="/assets/js/7.6f9d368d.js"><link rel="prefetch" href="/assets/js/8.516fa0e1.js"><link rel="prefetch" href="/assets/js/9.f1946ce5.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0dca6718.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container custom-page-class"><header class="navbar"><div class="ant-row"><div class="sidebar-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">Koala 's blog</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          Home
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item ant-menu-item-selected"><a href="/design/" class="router-link-active">
          设计模式
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/algorithm/">
          算法相关
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          java相关
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <!----></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/design/001_Preface.html" class="sidebar-link">前言</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>创建者模式</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>结构性模式</span> <span class="arrow down"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/design/009_StructuralPattern.html" class="sidebar-link">介绍</a></li><li><a href="/design/010_AdapterPattern.html" class="sidebar-link">适配器模式</a></li><li><a href="/design/011_BridgePattern.html" class="sidebar-link">桥接模式</a></li><li><a href="/design/012_CompositePattern.html" class="sidebar-link">组合模式</a></li><li><a href="/design/013_DecoratorPattern.html" class="sidebar-link">装饰模式</a></li><li><a href="/design/014_FacadePattern.html" class="sidebar-link">外观模式</a></li><li><a href="/design/015_FlyweightPattern.html" class="sidebar-link">享元模式</a></li><li><a href="/design/016_ProxyPattern.html" class="active sidebar-link">代理模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#定义" class="sidebar-link">定义</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#结构图" class="sidebar-link">结构图</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#典型代码" class="sidebar-link">典型代码</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#代理模式种类" class="sidebar-link">代理模式种类</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#扩展" class="sidebar-link">扩展</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#实例：商务信息的身份验证和日志记录" class="sidebar-link">实例：商务信息的身份验证和日志记录</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#java动态代理" class="sidebar-link">java动态代理</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#例子" class="sidebar-link">例子</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#优点" class="sidebar-link">优点</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#缺点" class="sidebar-link">缺点</a></li><li class="sidebar-sub-header"><a href="/design/016_ProxyPattern.html#适用场景" class="sidebar-link">适用场景</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>行为性模式</span> <span class="arrow right"><i aria-label="icon: down" class="anticon anticon-down"><svg viewBox="64 64 896 896" focusable="false" data-icon="down" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z"></path></svg></i></span></p> <!----></section></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h2 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h2> <blockquote><p>代理模式是一种应用很广泛的结构型设计模式，而且变化很多。在代理模式中引入了一个新的代理对象，代理对象可以在客户端对象和目标对象之间起到中介作用，去掉客户不能看到的内容和服务或者增添客户需要的额外服务。</p></blockquote> <h2 id="定义"><a href="#定义" aria-hidden="true" class="header-anchor">#</a> 定义</h2> <blockquote><p>代理模式(Proxy Pattern):给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式是一种对象结构型模式。</p></blockquote> <h2 id="结构图"><a href="#结构图" aria-hidden="true" class="header-anchor">#</a> 结构图</h2> <p><a data-fancybox="" title="结构图" href="/pic/design/MGXS4xg.png"><img src="/pic/design/MGXS4xg.png" alt="结构图"></a></p> <p>代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致地对待真实对象和代理对象，在代理模式中引入抽象模式，结构如上图</p> <p>由结构图可以看出</p> <ol><li><p><strong>Subject(抽象主题角色)</strong>:它声明了真实主题和代理主题的共同接口，使得在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程</p></li> <li><p><strong>Proxy(代理主题角色)</strong>:代理主题角色内部包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以代替真实主题对象；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或者之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</p></li> <li><p><strong>RealSubject(真实主题角色)</strong>:它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</p></li></ol> <h2 id="典型代码"><a href="#典型代码" aria-hidden="true" class="header-anchor">#</a> 典型代码</h2> <p>最简单的代理类实现代码如下:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>	class Proxy implements Subject<span class="token punctuation">{</span>
		
		private RealSubject realSubject <span class="token operator">=</span> new RealSubject<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	//维持一个对真实主题对象的引用

		public void preRequest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token punctuation">..</span><span class="token punctuation">..</span>
		<span class="token punctuation">}</span>

		public void request<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			preRequest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			realSubject.request<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>			//调用真实主题对象的方法
			postRequest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		public void postRequest<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
			<span class="token punctuation">..</span><span class="token punctuation">..</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><h2 id="代理模式种类"><a href="#代理模式种类" aria-hidden="true" class="header-anchor">#</a> 代理模式种类</h2> <p>在实际开发中，代理类的实现要复杂很多。代理模式根据其目的和实现方式不同可分成很多种类，其中常用的几种代理模式如下：</p> <ol><li><p><strong>远程代理（Remote Proxy）</strong>:为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中。远程代理又称为大使(Ambassador)</p></li> <li><p><strong>虚拟代码（Virtual Proxy）</strong>:如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实的对象只在被需要时才会被真正创建</p></li> <li><p><strong>保护代理(Protect Proxy)</strong>：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限</p></li> <li><p><strong>缓冲代理(Cache Proxy)</strong>:为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果</p></li> <li><p><strong>智能引用代理(Smart Reference Proxy)</strong>：当一个对象被引用时，提供一些额外操作，例如将对象被调用的次数记录下俩等</p></li></ol> <h2 id="扩展"><a href="#扩展" aria-hidden="true" class="header-anchor">#</a> 扩展</h2> <p>代理模式和装饰模式在实现时有些类似，但是代理模式主要是给真实主题类增加一些全新的职责，例如权限控制，缓冲处理，智能引用，远程访问等，这些职责与原有职责不属于同一问题域；而装饰模式是通过装饰类为具体构件类增加一些相关的职责，是对原有职责的扩展，这些职责属于同一问题域。代理模式和装饰模式的目的也不相同，前者是控制对对象的访问，而后者是为对象动态地增加功能</p> <h2 id="实例：商务信息的身份验证和日志记录"><a href="#实例：商务信息的身份验证和日志记录" aria-hidden="true" class="header-anchor">#</a> 实例：商务信息的身份验证和日志记录</h2> <p>使用代理模式设计商务信息查询系统的身份验证和日志记录</p> <h3 id="结构图-2"><a href="#结构图-2" aria-hidden="true" class="header-anchor">#</a> 结构图</h3> <p><a data-fancybox="" title="结构图" href="/pic/design/wbOioMd.png"><img src="/pic/design/wbOioMd.png" alt="结构图"></a></p> <p>业务类AccessValidator用于验证用户身份，它提供方法validate()来实现身份验证；业务类Logger用于记录用户查询日志，它提供方法log()来保存日志；RealSearcher充当真实主题角色，实现查询功能，它提供方法doSearch()来查询信息；ProxySearcher充当代理主题角色，它是查询代理，维持了对RealSearcher对象，AccessValidator对象和Logger对象的引用；Searcher充当抽象主题角色，声明了doSearch()方法。</p> <h3 id="代码实现"><a href="#代码实现" aria-hidden="true" class="header-anchor">#</a> 代码实现</h3> <p><strong>抽象查询类：抽象主题类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public interface Searcher <span class="token punctuation">{</span>
		public String doSearch<span class="token punctuation">(</span>String userId, String keyword<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>身份验证类：业务类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class AccessValidator <span class="token punctuation">{</span>
		//模拟实现登录验证
		public boolean validate<span class="token punctuation">(</span>String userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;在数据库中验证用户&quot;</span>+ userId + <span class="token string">&quot;是否是合法用户?&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			if<span class="token punctuation">(</span>userId.equalsIgnoreCase<span class="token punctuation">(</span><span class="token string">&quot;杨过&quot;</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>
				System.out.println<span class="token punctuation">(</span>userId + <span class="token string">&quot;登录成功！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>else <span class="token punctuation">{</span>
				System.out.println<span class="token punctuation">(</span>userId + <span class="token string">&quot;登录失败！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>日志记录类：业务员类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class Logger <span class="token punctuation">{</span>
		//模拟实现日志记录
		public void log<span class="token punctuation">(</span>String userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;更新数据库，用户&quot;</span>+ userId + <span class="token string">&quot;查询次数加1！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>具体查询类：真实主题类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class RealSearcher implements Searcher <span class="token punctuation">{</span>
		//模拟查询商务信息
		public String doSearch<span class="token punctuation">(</span>String userId, String keyword<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;用户&quot;</span> + userId + <span class="token string">&quot;使用关键词&quot;</span> + keyword + <span class="token string">&quot;查询商务信息!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token string">&quot;返回具体内容&quot;</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>代理查询类：代理主题类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class ProxySearcher implements Searcher <span class="token punctuation">{</span>
	
		//维持一个对真实主题的引用
		private RealSearcher searcher <span class="token operator">=</span> new RealSearcher<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		private AccessValidator validator<span class="token punctuation">;</span>
		
		private Logger logger<span class="token punctuation">;</span>
		
		@Override
		public String doSearch<span class="token punctuation">(</span>String userId, String keyword<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			//如果身份验证成功，则执行查询
			if<span class="token punctuation">(</span>validate<span class="token punctuation">(</span>userId<span class="token punctuation">))</span> <span class="token punctuation">{</span>
				//调用真实主题对象的查询方法
				String result <span class="token operator">=</span> searcher.doSearch<span class="token punctuation">(</span>userId, keyword<span class="token punctuation">)</span><span class="token punctuation">;</span> 
				//记录查询日志
				this.log<span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
				//返回查询结果
				<span class="token keyword">return</span> result<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>else <span class="token punctuation">{</span>
				<span class="token keyword">return</span> null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>

		//创建访问验证对象并调用其validate（）方法实现身份验证
		public boolean validate<span class="token punctuation">(</span>String userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			validator <span class="token operator">=</span> new AccessValidator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> validator.validate<span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		//创建日志记录对象并调用log（）方法实现日志记录
		public void log<span class="token punctuation">(</span>String userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			logger <span class="token operator">=</span> new Logger<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			logger.log<span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>工具类XMLUtil：用来读取配置文件来反射生成对象</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class XMLUtil <span class="token punctuation">{</span>
		public static Object getBean<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			try <span class="token punctuation">{</span>
				//创建文档对象
				DocumentBuilderFactory dFactory <span class="token operator">=</span> DocumentBuilderFactory.newInstance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				DocumentBuilder builder <span class="token operator">=</span> dFactory.newDocumentBuilder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				Document doc<span class="token punctuation">;</span>
				doc <span class="token operator">=</span> builder.parse<span class="token punctuation">(</span>new File<span class="token punctuation">(</span><span class="token string">&quot;config.xml&quot;</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
				
				//获取包含类名的文本节点
				NodeList <span class="token function">nl</span> <span class="token operator">=</span> doc.getElementsByTagName<span class="token punctuation">(</span><span class="token string">&quot;className&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				Node classNode <span class="token operator">=</span> nl.item<span class="token punctuation">(</span>0<span class="token punctuation">)</span>.getFirstChild<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				String cName <span class="token operator">=</span> classNode.getNodeName<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				
				//通过类名生成实例对象并将其返回
				Class c <span class="token operator">=</span> Class.forName<span class="token punctuation">(</span>cName<span class="token punctuation">)</span><span class="token punctuation">;</span>
				Object obj <span class="token operator">=</span> c.newInstance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> obj<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>catch <span class="token punctuation">(</span>Exception e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
				e.printStackTrace<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> null<span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>配置文件存储了代理主题类的类名</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	<span class="token operator">&lt;</span>?xml version<span class="token operator">=</span><span class="token string">&quot;1.0&quot;</span><span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>config<span class="token operator">&gt;</span>
		<span class="token operator">&lt;</span>className<span class="token operator">&gt;</span>ProxySearcher<span class="token operator">&lt;</span>/className<span class="token operator">&gt;</span>
	<span class="token operator">&lt;</span>/config<span class="token operator">&gt;</span>
</code></pre></div><p><strong>客户端测试</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class Client <span class="token punctuation">{</span>
	
		public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			//针对抽象编程，客户端无需分辨真实主题类和代理类
			Searcher searcher<span class="token punctuation">;</span>
			searcher <span class="token operator">=</span> <span class="token punctuation">(</span>Searcher<span class="token punctuation">)</span>XMLUtil.getBean<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			String result <span class="token operator">=</span> searcher.doSearch<span class="token punctuation">(</span><span class="token string">&quot;杨过&quot;</span>, <span class="token string">&quot;小龙女&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><p>本实例是保护代理和智能引用代理的应用实例，在代理类ProxySearcher中实现对真实主题类的权限控制和引用计数，如果需要在访问真实主题时增加新的访问控制机制和新功能，只需增加一个新的代理类，再修改配置文件，在客户端代码中使用新增代理类即可，源代码无须修改，符合开闭原则</p> <h2 id="java动态代理"><a href="#java动态代理" aria-hidden="true" class="header-anchor">#</a> java动态代理</h2> <p>通常情况下，每一个代理类编译之后都会生成一个class文件，代理类所实现的接口和所代理的方法都被固定，这种代理被称之为静态代理（Static Proxy），还有一种机制能够让系统在运行时动态创建代理类，叫做动态代理(Dynamic Proxy)，动态代理是一种较为高级的代理模式，它在事务管理，AOP(Aspect-Oriented Programming,面向方面编程)等领域都发挥了重要的作用。</p> <p>Java语言实现动态代理时需要用到位于java.lang.reflect包中的一些类，如下</p> <p><strong>1. Proxy类</strong></p> <p>Proxy类提供给了用于创建动态代理类和实例对象的方法，它是所创建的动态代理类的父类，最常用的方法如下：</p> <p><strong>(1) public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;...interfaces)</strong>.该方法用于返回一个Class类型的代理类，在参数中需要提供类加载器并需要指定代理的接口数组（与真实主题类的接口列表一致）</p> <p><strong>(2) public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</strong> 该方法用于返回一个动态创建的代理类的实例，方法中的第1个参数loader表示代理类的类加载器，第2个参数interfaces表示代理类所实现的接口列表(与真实主题类的接口列表一致)，第3个参数h表示所指派的调用处理程序类</p> <p><strong>2. InvocationHandler接口</strong></p> <p>InvocationHandler接口是代理处理程序类的实现接口，该接口作为代理实例的调用处理者的公共父类，每一个代理类的实例都可以提供一个相关的具体调用处理者(InvocationHandler接口的子类)。该接口中声明了如下方法：</p> <p><strong>public Object invoke(Object proxy, Method method, Object[] args).</strong> 该方法用于处理对代理类实例的方法调用并返回相应的结果，当一个代理实例中的业务方法被调用时将自动调用该方法。invoke()方法包含3个参数，其中，第1个参数proxy表示代理类的实例，第2个参数method表示需要代理的方法，第3个参数args表示代理方法的参数数组</p> <p>动态代理类需要在运行时指定所代理真实主题类的接口，客户端在调用动态代理对象的方法时，调用请求会将请求自动转发给InvocationHandler对象的invoke()方法，由invoke()方法来实现对请求的统一处理</p> <h2 id="例子"><a href="#例子" aria-hidden="true" class="header-anchor">#</a> 例子</h2> <p>使用动态代理进行设计与实现调用日志，用于记录数据访问层DAO每一个方法被调用的时间和调用的结果</p> <h3 id="代码实现-2"><a href="#代码实现-2" aria-hidden="true" class="header-anchor">#</a> 代码实现</h3> <p><strong>抽象UserDAO：抽象主题角色</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public interface AbstractUserDAO <span class="token punctuation">{</span>
		public Boolean findUserById<span class="token punctuation">(</span>String userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>抽象DocumentDAO：抽象主题角色</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public interface AbstractDocumentDAO <span class="token punctuation">{</span>
		public Boolean deleteDocumentById<span class="token punctuation">(</span>String documentId<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>具体UserDAO类：真实角色</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class UserDAO implements AbstractUserDAO <span class="token punctuation">{</span>
	
		public Boolean findUserById<span class="token punctuation">(</span>String userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			if<span class="token punctuation">(</span>userId.equalsIgnoreCase<span class="token punctuation">(</span><span class="token string">&quot;张无忌&quot;</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>
				System.out.println<span class="token punctuation">(</span><span class="token string">&quot;查询ID为&quot;</span>+ userId + <span class="token string">&quot;的用户信息成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>else <span class="token punctuation">{</span>
				System.out.println<span class="token punctuation">(</span><span class="token string">&quot;查询ID为&quot;</span>+ userId + <span class="token string">&quot;的用户信息成功&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>具体DocumentDAO类：真实角色</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class DocumentDAO implements AbstractDocumentDAO <span class="token punctuation">{</span>
	
		public Boolean deleteDocumentById<span class="token punctuation">(</span>String documentId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			if<span class="token punctuation">(</span>documentId.equalsIgnoreCase<span class="token punctuation">(</span><span class="token string">&quot;D001&quot;</span><span class="token punctuation">))</span> <span class="token punctuation">{</span>
				System.out.println<span class="token punctuation">(</span><span class="token string">&quot;删除ID为&quot;</span> + documentId + <span class="token string">&quot;的文档信息成功!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>else<span class="token punctuation">{</span>
				System.out.println<span class="token punctuation">(</span><span class="token string">&quot;删除ID为&quot;</span> + documentId + <span class="token string">&quot;的文档信息失败!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>自定义请求处理程序类</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class DAOLogHandler implements InvocationHandler <span class="token punctuation">{</span>
	
		private Calendar calendar<span class="token punctuation">;</span>
		private Object object<span class="token punctuation">;</span>
		
		public DAOLogHandler<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			// TODO Auto-generated constructor stub
		<span class="token punctuation">}</span>
		
		//自定义有参构造函数，用于注入一个需要提供代理的真实主题对象
		public DAOLogHandler<span class="token punctuation">(</span>Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			this.object <span class="token operator">=</span> object<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		//实现invoke<span class="token punctuation">(</span><span class="token punctuation">)</span>方法，调用在真实主题类中定义的方法
		public Object invoke<span class="token punctuation">(</span>Object obj, Method method, Object<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> throws Throwable <span class="token punctuation">{</span>
			beforeInvoke<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			Object result <span class="token operator">=</span> method.invoke<span class="token punctuation">(</span>obj, args<span class="token punctuation">)</span><span class="token punctuation">;</span>	//转发调用
			afterInoke<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span> result<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		//记录方法调用时间
		public void beforeInvoke<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			calendar <span class="token operator">=</span> new GregorianCalendar<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			int hour <span class="token operator">=</span> calendar.get<span class="token punctuation">(</span>Calendar.HOUR_OF_DAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
			int minute <span class="token operator">=</span> calendar.get<span class="token punctuation">(</span>Calendar.MINUTE<span class="token punctuation">)</span><span class="token punctuation">;</span>
			int second <span class="token operator">=</span> calendar.get<span class="token punctuation">(</span>Calendar.SECOND<span class="token punctuation">)</span><span class="token punctuation">;</span>
			String <span class="token function">time</span> <span class="token operator">=</span> hour + <span class="token string">&quot;:&quot;</span> + minute + <span class="token string">&quot;:&quot;</span> + second<span class="token punctuation">;</span>
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;调用时间：&quot;</span>+time<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		public void afterInoke<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;方法调用结束！&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><p><strong>客户端实现</strong></p> <div class="language-bash extra-class"><pre class="language-bash"><code>	public class Client <span class="token punctuation">{</span>
		public static void main<span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
			InvocationHandler handler <span class="token operator">=</span> null<span class="token punctuation">;</span>
			
			AbstractUserDAO userDAO <span class="token operator">=</span> new UserDAO<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			handler <span class="token operator">=</span> new DAOLogHandler<span class="token punctuation">(</span>userDAO<span class="token punctuation">)</span><span class="token punctuation">;</span>
			AbstractUserDAO proxy <span class="token operator">=</span> null<span class="token punctuation">;</span>
			//动态创建代理对象，用于代理一个AbstractUserDAO类型的真实主题对象
			proxy <span class="token operator">=</span> <span class="token punctuation">(</span>AbstractUserDAO<span class="token punctuation">)</span> Proxy.newProxyInstance<span class="token punctuation">(</span>
						AbstractUserDAO.class.getClassLoader<span class="token punctuation">(</span><span class="token punctuation">)</span>, 
						new Class<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>AbstractUserDAO.class<span class="token punctuation">}</span>,
						handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
			
			//调用代理对象的业务方法
			proxy.findUserById<span class="token punctuation">(</span><span class="token string">&quot;张无忌&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 	
			
			System.out.println<span class="token punctuation">(</span><span class="token string">&quot;----------------------&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			
			AbstractDocumentDAO docDAO <span class="token operator">=</span> new DocumentDAO<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			handler <span class="token operator">=</span> new DAOLogHandler<span class="token punctuation">(</span>docDAO<span class="token punctuation">)</span><span class="token punctuation">;</span>
			AbstractDocumentDAO proxy_new <span class="token operator">=</span> null<span class="token punctuation">;</span>
			//动态创建代理对象，用于代理一个AbstractDocumentDAO类型的真实主题对象
			proxy_new <span class="token operator">=</span> <span class="token punctuation">(</span>AbstractDocumentDAO<span class="token punctuation">)</span> Proxy.newProxyInstance<span class="token punctuation">(</span>
					AbstractDocumentDAO.class.getClassLoader<span class="token punctuation">(</span><span class="token punctuation">)</span>,
					new Class<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>AbstractDocumentDAO.class<span class="token punctuation">}</span>,
					handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
			//调用代理对象的业务方法
			proxy_new.deleteDocumentById<span class="token punctuation">(</span><span class="token string">&quot;D002&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>注：JDK中提供的动态代理只能代理一个或者多个接口，如果需要动态代理具体类或抽象类，可以使用CGLibe(Code Generation Library)等工具。CGLib是一个功能较为强大，性能和质量较好的代码生成包，许多AOP框架中得到很广泛应用。</p></blockquote> <h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <p>代理模式是常用的结构型设计模式之一，它为对象的间接访问提供了一个解决方案，可以对对象的间接访问提供一个解决方案，可以对对象的访问进行控制。代理模式类型较多，其中远程代理，虚拟代理，保护代理等在软件开发中应用非常广泛。在JavaRMI，EJB，Web Service，Spring AOP等技术和框架中都使用了代理模式</p> <h2 id="优点"><a href="#优点" aria-hidden="true" class="header-anchor">#</a> 优点</h2> <ol><li><p>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度，满足迪米特法则</p></li> <li><p>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性</p></li> <li><p>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提供系统的整体运行效率</p></li> <li><p>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销</p></li> <li><p>保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限</p></li></ol> <h2 id="缺点"><a href="#缺点" aria-hidden="true" class="header-anchor">#</a> 缺点</h2> <ol><li><p>由于客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理</p></li> <li><p>实现代理模式需要额外的工作，有些代理模式的实现非常复杂，例如远程代理</p></li></ol> <h2 id="适用场景"><a href="#适用场景" aria-hidden="true" class="header-anchor">#</a> 适用场景</h2> <p>代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合</p> <ol><li><p>当客户端对象需要访问远程主机中的对象时，可以使用远程代理</p></li> <li><p>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销，缩短运行时间时，可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。</p></li> <li><p>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时，可以使用保护代理</p></li> <li><p>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时，可以使用缓冲代理，通过缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。</p></li> <li><p>当需要为一个对象的访问(引用)提供一些额外的操作时，可以使用智能引用代理</p></li></ol></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">9/22/2020, 12:20:37 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/design/015_FlyweightPattern.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        享元模式
      </a></span> <span class="next"><a href="/design/017_BehavioralPattern.html">
        介绍
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.193c9b61.js" defer></script><script src="/assets/js/2.be286493.js" defer></script><script src="/assets/js/32.e6285297.js" defer></script>
  </body>
</html>